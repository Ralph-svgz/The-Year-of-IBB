"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@monogrid";
exports.ids = ["vendor-chunks/@monogrid"];
exports.modules = {

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/Loader-BZcKUVaX.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/Loader-BZcKUVaX.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   G: () => (/* binding */ GainMapNotFoundError),\n/* harmony export */   L: () => (/* binding */ LoaderBaseShared),\n/* harmony export */   M: () => (/* binding */ MPFExtractor),\n/* harmony export */   X: () => (/* binding */ XMPMetadataNotFoundError),\n/* harmony export */   a: () => (/* binding */ extractXMP),\n/* harmony export */   c: () => (/* binding */ createDecodeFunction),\n/* harmony export */   e: () => (/* binding */ extractGainmapFromJPEG)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/**\n * @monogrid/gainmap-js v3.2.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */ \n/**\n * Shared decode implementation factory\n * Creates a decode function that prepares a QuadRenderer with the given parameters\n */ function createDecodeFunction(config) {\n    return (params)=>{\n        const { sdr, gainMap, renderer } = params;\n        if (sdr.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n            console.warn(\"SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically\");\n            sdr.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        }\n        sdr.needsUpdate = true;\n        if (gainMap.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace) {\n            console.warn(\"Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically\");\n            gainMap.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n        }\n        gainMap.needsUpdate = true;\n        const material = config.createMaterial({\n            ...params,\n            sdr,\n            gainMap\n        });\n        const quadRenderer = config.createQuadRenderer({\n            width: sdr.image.width,\n            height: sdr.image.height,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n            material,\n            renderer,\n            renderTargetOptions: params.renderTargetOptions\n        });\n        return quadRenderer;\n    };\n}\nclass GainMapNotFoundError extends Error {\n}\nclass XMPMetadataNotFoundError extends Error {\n}\nconst getXMLValue = (xml, tag, defaultValue)=>{\n    // Check for attribute format first: tag=\"value\"\n    const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, \"i\").exec(xml);\n    if (attributeMatch) return attributeMatch[1];\n    // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n    const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, \"i\").exec(xml);\n    if (tagMatch) {\n        // Check if it contains rdf:li elements\n        const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n        if (liValues && liValues.length === 3) {\n            return liValues.map((v)=>v.replace(/<\\/?rdf:li>/g, \"\"));\n        }\n        return tagMatch[1].trim();\n    }\n    if (defaultValue !== undefined) return defaultValue;\n    throw new Error(`Can't find ${tag} in gainmap metadata`);\n};\nconst extractXMP = (input)=>{\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== \"undefined\") str = new TextDecoder().decode(input);\n    else str = input.toString();\n    let start = str.indexOf(\"<x:xmpmeta\");\n    while(start !== -1){\n        const end = str.indexOf(\"x:xmpmeta>\", start);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const gainMapMin = getXMLValue(xmpBlock, \"hdrgm:GainMapMin\", \"0\");\n            const gainMapMax = getXMLValue(xmpBlock, \"hdrgm:GainMapMax\");\n            const gamma = getXMLValue(xmpBlock, \"hdrgm:Gamma\", \"1\");\n            const offsetSDR = getXMLValue(xmpBlock, \"hdrgm:OffsetSDR\", \"0.015625\");\n            const offsetHDR = getXMLValue(xmpBlock, \"hdrgm:OffsetHDR\", \"0.015625\");\n            // These are always attributes, so we can use a simpler regex\n            const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n            const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : \"0\";\n            const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n            if (!hdrCapacityMaxMatch) throw new Error(\"Incomplete gainmap metadata\");\n            const hdrCapacityMax = hdrCapacityMaxMatch[1];\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map((v)=>parseFloat(v)) : [\n                    parseFloat(gainMapMin),\n                    parseFloat(gainMapMin),\n                    parseFloat(gainMapMin)\n                ],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map((v)=>parseFloat(v)) : [\n                    parseFloat(gainMapMax),\n                    parseFloat(gainMapMax),\n                    parseFloat(gainMapMax)\n                ],\n                gamma: Array.isArray(gamma) ? gamma.map((v)=>parseFloat(v)) : [\n                    parseFloat(gamma),\n                    parseFloat(gamma),\n                    parseFloat(gamma)\n                ],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map((v)=>parseFloat(v)) : [\n                    parseFloat(offsetSDR),\n                    parseFloat(offsetSDR),\n                    parseFloat(offsetSDR)\n                ],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map((v)=>parseFloat(v)) : [\n                    parseFloat(offsetHDR),\n                    parseFloat(offsetHDR),\n                    parseFloat(offsetHDR)\n                ],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        } catch (e) {\n        // Continue searching for another xmpmeta block if this one fails\n        }\n        start = str.indexOf(\"<x:xmpmeta\", end);\n    }\n};\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */ class MPFExtractor {\n    constructor(options){\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject)=>{\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error(\"Not a valid jpeg\"));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while(offset < length){\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops üòµ`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug) console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug) console.log(\"Found APP2 marker (0xffe2)\");\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */ if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        } else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        } else {\n                            reject(new Error(\"No valid endianness marker found in TIFF header\"));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error(\"Not valid TIFF data! (no 0x002A marker)\"));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error(\"Not valid TIFF data! (First offset less than 8)\"));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for(let i = entriesStart; i < entriesStart + 12 * count; i += 12){\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for(let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16){\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            } else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([\n                                dataView\n                            ]);\n                            const imgs = [];\n                            for (const image of images){\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, \"image/jpeg\");\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */ const extractGainmapFromJPEG = async (jpegFile)=>{\n    const metadata = extractXMP(jpegFile);\n    if (!metadata) throw new XMPMetadataNotFoundError(\"Gain map XMP metadata not found\");\n    const mpfExtractor = new MPFExtractor({\n        extractFII: true,\n        extractNonFII: true\n    });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2) throw new GainMapNotFoundError(\"Gain map recovery image not found\");\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */ const getHTMLImageFromBlob = (blob)=>{\n    return new Promise((resolve, reject)=>{\n        const img = document.createElement(\"img\");\n        img.onload = ()=>{\n            resolve(img);\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        img.onerror = (e)=>{\n            reject(e);\n        };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n/**\n * Shared base class for loaders that extracts common logic\n */ class LoaderBaseShared extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(config, manager){\n        super(manager);\n        this._config = config;\n        if (config.renderer) this._renderer = config.renderer;\n        this._internalLoadingManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    }\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    prepareQuadRenderer() {\n        if (!this._renderer) {\n            console.warn(\"WARNING: A Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.\");\n        }\n        const material = this._config.createMaterial({\n            gainMapMax: [\n                1,\n                1,\n                1\n            ],\n            gainMapMin: [\n                0,\n                0,\n                0\n            ],\n            gamma: [\n                1,\n                1,\n                1\n            ],\n            offsetHdr: [\n                1,\n                1,\n                1\n            ],\n            offsetSdr: [\n                1,\n                1,\n                1\n            ],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new three__WEBPACK_IMPORTED_MODULE_0__.Texture(),\n            sdr: new three__WEBPACK_IMPORTED_MODULE_0__.Texture()\n        });\n        return this._config.createQuadRenderer({\n            width: 16,\n            height: 16,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    async processImages(sdrBuffer, gainMapBuffer, imageOrientation) {\n        const gainMapBlob = gainMapBuffer ? new Blob([\n            gainMapBuffer\n        ], {\n            type: \"image/jpeg\"\n        }) : undefined;\n        const sdrBlob = new Blob([\n            sdrBuffer\n        ], {\n            type: \"image/jpeg\"\n        });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === \"undefined\") {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = imageOrientation === \"flipY\";\n        } else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, {\n                    imageOrientation: imageOrientation || \"flipY\"\n                }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, {\n                    imageOrientation: imageOrientation || \"flipY\"\n                })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        return {\n            sdrImage,\n            gainMapImage,\n            needsFlip\n        };\n    }\n    createTextures(sdrImage, gainMapImage, needsFlip) {\n        const gainMap = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(gainMapImage || new ImageData(2, 2), three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(sdrImage, three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        return {\n            gainMap,\n            sdr\n        };\n    }\n    updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata) {\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9Mb2FkZXItQlpjS1VWYVguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFa047QUFFbk47OztDQUdDLEdBQ0QsU0FBU1kscUJBQXFCQyxNQUFNO0lBQ2hDLE9BQU8sQ0FBQ0M7UUFDSixNQUFNLEVBQUVDLEdBQUcsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUUsR0FBR0g7UUFDbkMsSUFBSUMsSUFBSUcsVUFBVSxLQUFLbEIsaURBQWNBLEVBQUU7WUFDbkNtQixRQUFRQyxJQUFJLENBQUM7WUFDYkwsSUFBSUcsVUFBVSxHQUFHbEIsaURBQWNBO1FBQ25DO1FBQ0FlLElBQUlNLFdBQVcsR0FBRztRQUNsQixJQUFJTCxRQUFRRSxVQUFVLEtBQUtqQix1REFBb0JBLEVBQUU7WUFDN0NrQixRQUFRQyxJQUFJLENBQUM7WUFDYkosUUFBUUUsVUFBVSxHQUFHakIsdURBQW9CQTtRQUM3QztRQUNBZSxRQUFRSyxXQUFXLEdBQUc7UUFDdEIsTUFBTUMsV0FBV1QsT0FBT1UsY0FBYyxDQUFDO1lBQ25DLEdBQUdULE1BQU07WUFDVEM7WUFDQUM7UUFDSjtRQUNBLE1BQU1RLGVBQWVYLE9BQU9ZLGtCQUFrQixDQUFDO1lBQzNDQyxPQUFPWCxJQUFJWSxLQUFLLENBQUNELEtBQUs7WUFDdEJFLFFBQVFiLElBQUlZLEtBQUssQ0FBQ0MsTUFBTTtZQUN4QkMsTUFBTTNCLGdEQUFhQTtZQUNuQmdCLFlBQVlqQix1REFBb0JBO1lBQ2hDcUI7WUFDQUw7WUFDQWEscUJBQXFCaEIsT0FBT2dCLG1CQUFtQjtRQUNuRDtRQUNBLE9BQU9OO0lBQ1g7QUFDSjtBQUVBLE1BQU1PLDZCQUE2QkM7QUFDbkM7QUFFQSxNQUFNQyxpQ0FBaUNEO0FBQ3ZDO0FBRUEsTUFBTUUsY0FBYyxDQUFDQyxLQUFLQyxLQUFLQztJQUMzQixnREFBZ0Q7SUFDaEQsTUFBTUMsaUJBQWlCLElBQUlDLE9B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cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pdmVyc2l0eS15ZWFycy8uL25vZGVfbW9kdWxlcy9AbW9ub2dyaWQvZ2Fpbm1hcC1qcy9kaXN0L0xvYWRlci1CWmNLVVZhWC5qcz9hYmVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vbm9ncmlkL2dhaW5tYXAtanMgdjMuMi4wXG4gKiBXaXRoIOKdpO+4jywgYnkgTU9OT0dSSUQgPGdhaW5tYXBAbW9ub2dyaWQuY29tPlxuICovXG5cbmltcG9ydCB7IFNSR0JDb2xvclNwYWNlLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSwgSGFsZkZsb2F0VHlwZSwgTG9hZGVyLCBMb2FkaW5nTWFuYWdlciwgVGV4dHVyZSwgVVZNYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcE1hcExpbmVhckZpbHRlciwgUkdCQUZvcm1hdCwgVW5zaWduZWRCeXRlVHlwZSB9IGZyb20gJ3RocmVlJztcblxuLyoqXG4gKiBTaGFyZWQgZGVjb2RlIGltcGxlbWVudGF0aW9uIGZhY3RvcnlcbiAqIENyZWF0ZXMgYSBkZWNvZGUgZnVuY3Rpb24gdGhhdCBwcmVwYXJlcyBhIFF1YWRSZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlY29kZUZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHJldHVybiAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2RyLCBnYWluTWFwLCByZW5kZXJlciB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAoc2RyLmNvbG9yU3BhY2UgIT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NEUiBDb2xvcnNwYWNlIG5lZWRzIHRvIGJlICpTUkdCQ29sb3JTcGFjZSosIHNldHRpbmcgaXQgYXV0b21hdGljYWxseScpO1xuICAgICAgICAgICAgc2RyLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBzZHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBpZiAoZ2Fpbk1hcC5jb2xvclNwYWNlICE9PSBMaW5lYXJTUkdCQ29sb3JTcGFjZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdHYWlubWFwIENvbG9yc3BhY2UgbmVlZHMgdG8gYmUgKkxpbmVhclNSR0JDb2xvclNwYWNlKiwgc2V0dGluZyBpdCBhdXRvbWF0aWNhbGx5Jyk7XG4gICAgICAgICAgICBnYWluTWFwLmNvbG9yU3BhY2UgPSBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBnYWluTWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBjb25maWcuY3JlYXRlTWF0ZXJpYWwoe1xuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgc2RyLFxuICAgICAgICAgICAgZ2Fpbk1hcFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcXVhZFJlbmRlcmVyID0gY29uZmlnLmNyZWF0ZVF1YWRSZW5kZXJlcih7XG4gICAgICAgICAgICB3aWR0aDogc2RyLmltYWdlLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBzZHIuaW1hZ2UuaGVpZ2h0LFxuICAgICAgICAgICAgdHlwZTogSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgICAgIGNvbG9yU3BhY2U6IExpbmVhclNSR0JDb2xvclNwYWNlLFxuICAgICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgICByZW5kZXJlcixcbiAgICAgICAgICAgIHJlbmRlclRhcmdldE9wdGlvbnM6IHBhcmFtcy5yZW5kZXJUYXJnZXRPcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcXVhZFJlbmRlcmVyO1xuICAgIH07XG59XG5cbmNsYXNzIEdhaW5NYXBOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5jbGFzcyBYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5cbmNvbnN0IGdldFhNTFZhbHVlID0gKHhtbCwgdGFnLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICAvLyBDaGVjayBmb3IgYXR0cmlidXRlIGZvcm1hdCBmaXJzdDogdGFnPVwidmFsdWVcIlxuICAgIGNvbnN0IGF0dHJpYnV0ZU1hdGNoID0gbmV3IFJlZ0V4cChgJHt0YWd9PVwiKFteXCJdKilcImAsICdpJykuZXhlYyh4bWwpO1xuICAgIGlmIChhdHRyaWJ1dGVNYXRjaClcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU1hdGNoWzFdO1xuICAgIC8vIENoZWNrIGZvciB0YWcgZm9ybWF0OiA8dGFnPnZhbHVlPC90YWc+IG9yIDx0YWc+PHJkZjpsaT52YWx1ZTwvcmRmOmxpPi4uLjwvdGFnPlxuICAgIGNvbnN0IHRhZ01hdGNoID0gbmV3IFJlZ0V4cChgPCR7dGFnfVtePl0qPihbXFxcXHNcXFxcU10qPyk8LyR7dGFnfT5gLCAnaScpLmV4ZWMoeG1sKTtcbiAgICBpZiAodGFnTWF0Y2gpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY29udGFpbnMgcmRmOmxpIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IGxpVmFsdWVzID0gdGFnTWF0Y2hbMV0ubWF0Y2goLzxyZGY6bGk+KFtePF0qKTxcXC9yZGY6bGk+L2cpO1xuICAgICAgICBpZiAobGlWYWx1ZXMgJiYgbGlWYWx1ZXMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlWYWx1ZXMubWFwKHYgPT4gdi5yZXBsYWNlKC88XFwvP3JkZjpsaT4vZywgJycpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnTWF0Y2hbMV0udHJpbSgpO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kICR7dGFnfSBpbiBnYWlubWFwIG1ldGFkYXRhYCk7XG59O1xuY29uc3QgZXh0cmFjdFhNUCA9IChpbnB1dCkgPT4ge1xuICAgIGxldCBzdHI7XG4gICAgLy8gc3VwcG9ydCBub2RlIHRlc3QgZW52aXJvbm1lbnRcbiAgICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgc3RyID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGlucHV0KTtcbiAgICBlbHNlXG4gICAgICAgIHN0ciA9IGlucHV0LnRvU3RyaW5nKCk7XG4gICAgbGV0IHN0YXJ0ID0gc3RyLmluZGV4T2YoJzx4OnhtcG1ldGEnKTtcbiAgICB3aGlsZSAoc3RhcnQgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0ci5pbmRleE9mKCd4OnhtcG1ldGE+Jywgc3RhcnQpO1xuICAgICAgICBjb25zdCB4bXBCbG9jayA9IHN0ci5zbGljZShzdGFydCwgZW5kICsgMTApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZ2Fpbk1hcE1pbiA9IGdldFhNTFZhbHVlKHhtcEJsb2NrLCAnaGRyZ206R2Fpbk1hcE1pbicsICcwJyk7XG4gICAgICAgICAgICBjb25zdCBnYWluTWFwTWF4ID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpHYWluTWFwTWF4Jyk7XG4gICAgICAgICAgICBjb25zdCBnYW1tYSA9IGdldFhNTFZhbHVlKHhtcEJsb2NrLCAnaGRyZ206R2FtbWEnLCAnMScpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0U0RSID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpPZmZzZXRTRFInLCAnMC4wMTU2MjUnKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldEhEUiA9IGdldFhNTFZhbHVlKHhtcEJsb2NrLCAnaGRyZ206T2Zmc2V0SERSJywgJzAuMDE1NjI1Jyk7XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgYWx3YXlzIGF0dHJpYnV0ZXMsIHNvIHdlIGNhbiB1c2UgYSBzaW1wbGVyIHJlZ2V4XG4gICAgICAgICAgICBjb25zdCBoZHJDYXBhY2l0eU1pbk1hdGNoID0gL2hkcmdtOkhEUkNhcGFjaXR5TWluPVwiKFteXCJdKilcIi8uZXhlYyh4bXBCbG9jayk7XG4gICAgICAgICAgICBjb25zdCBoZHJDYXBhY2l0eU1pbiA9IGhkckNhcGFjaXR5TWluTWF0Y2ggPyBoZHJDYXBhY2l0eU1pbk1hdGNoWzFdIDogJzAnO1xuICAgICAgICAgICAgY29uc3QgaGRyQ2FwYWNpdHlNYXhNYXRjaCA9IC9oZHJnbTpIRFJDYXBhY2l0eU1heD1cIihbXlwiXSopXCIvLmV4ZWMoeG1wQmxvY2spO1xuICAgICAgICAgICAgaWYgKCFoZHJDYXBhY2l0eU1heE1hdGNoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wbGV0ZSBnYWlubWFwIG1ldGFkYXRhJyk7XG4gICAgICAgICAgICBjb25zdCBoZHJDYXBhY2l0eU1heCA9IGhkckNhcGFjaXR5TWF4TWF0Y2hbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdhaW5NYXBNaW46IEFycmF5LmlzQXJyYXkoZ2Fpbk1hcE1pbikgPyBnYWluTWFwTWluLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQoZ2Fpbk1hcE1pbiksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1pbiksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1pbildLFxuICAgICAgICAgICAgICAgIGdhaW5NYXBNYXg6IEFycmF5LmlzQXJyYXkoZ2Fpbk1hcE1heCkgPyBnYWluTWFwTWF4Lm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQoZ2Fpbk1hcE1heCksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1heCksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1heCldLFxuICAgICAgICAgICAgICAgIGdhbW1hOiBBcnJheS5pc0FycmF5KGdhbW1hKSA/IGdhbW1hLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQoZ2FtbWEpLCBwYXJzZUZsb2F0KGdhbW1hKSwgcGFyc2VGbG9hdChnYW1tYSldLFxuICAgICAgICAgICAgICAgIG9mZnNldFNkcjogQXJyYXkuaXNBcnJheShvZmZzZXRTRFIpID8gb2Zmc2V0U0RSLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQob2Zmc2V0U0RSKSwgcGFyc2VGbG9hdChvZmZzZXRTRFIpLCBwYXJzZUZsb2F0KG9mZnNldFNEUildLFxuICAgICAgICAgICAgICAgIG9mZnNldEhkcjogQXJyYXkuaXNBcnJheShvZmZzZXRIRFIpID8gb2Zmc2V0SERSLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQob2Zmc2V0SERSKSwgcGFyc2VGbG9hdChvZmZzZXRIRFIpLCBwYXJzZUZsb2F0KG9mZnNldEhEUildLFxuICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWluOiBwYXJzZUZsb2F0KGhkckNhcGFjaXR5TWluKSxcbiAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1heDogcGFyc2VGbG9hdChoZHJDYXBhY2l0eU1heClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHNlYXJjaGluZyBmb3IgYW5vdGhlciB4bXBtZXRhIGJsb2NrIGlmIHRoaXMgb25lIGZhaWxzXG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBzdHIuaW5kZXhPZignPHg6eG1wbWV0YScsIGVuZCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNUEYgRXh0cmFjdG9yIChNdWx0aSBQaWN0dXJlIEZvcm1hdCBFeHRyYWN0b3IpXG4gKiBCeSBIZW5yaWsgUyBOaWxzc29uIDIwMTlcbiAqXG4gKiBFeHRyYWN0cyBpbWFnZXMgc3RvcmVkIGluIGltYWdlcyBiYXNlZCBvbiB0aGUgTVBGIGZvcm1hdCAoZm91bmQgaGVyZTogaHR0cHM6Ly93d3cuY2lwYS5qcC9lL3N0ZC9zdGQtc2VjLmh0bWxcbiAqIHVuZGVyIFwiQ0lQQSBEQy0wMDctVHJhbnNsYXRpb24tMjAyMSBNdWx0aS1QaWN0dXJlIEZvcm1hdFwiXG4gKlxuICogT3Zlcmx5IGNvbW1lbnRlZCwgYW5kIHdpdGhvdXQgaW50ZW50aW9uIG9mIGJlaW5nIGNvbXBsZXRlIG9yIHByb2R1Y3Rpb24gcmVhZHkuXG4gKiBDcmVhdGVkIHRvIGV4dHJhY3QgZGVwdGggbWFwcyBmcm9tIGlQaG9uZSBpbWFnZXMsIGFuZCB0byBsZWFybiBhYm91dCBpbWFnZSBtZXRhZGF0YS5cbiAqIEt1ZG9zIHRvOiBQaGlsIEhhcnZleSAoZXhpZnRvb2wpLCBKYXVtZSBTYW5jaGV6IChhbmRyb2lkLWxlbnMtYmx1ci1kZXB0aC1leHRyYWN0b3IpXG4gKi9cbmNsYXNzIE1QRkV4dHJhY3RvciB7XG4gICAgb3B0aW9ucztcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRlYnVnOiBvcHRpb25zICYmIG9wdGlvbnMuZGVidWcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVidWcgOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dHJhY3RGSUk6IG9wdGlvbnMgJiYgb3B0aW9ucy5leHRyYWN0RklJICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmV4dHJhY3RGSUkgOiB0cnVlLFxuICAgICAgICAgICAgZXh0cmFjdE5vbkZJSTogb3B0aW9ucyAmJiBvcHRpb25zLmV4dHJhY3ROb25GSUkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0cmFjdE5vbkZJSSA6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXh0cmFjdChpbWFnZUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWJ1ZyA9IHRoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGltYWdlQXJyYXlCdWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgIC8vIElmIHlvdSdyZSBleGVjdXRpbmcgdGhpcyBsaW5lIG9uIGEgYmlnIGVuZGlhbiBtYWNoaW5lLCBpdCdsbCBiZSByZXZlcnNlZC5cbiAgICAgICAgICAgIC8vIGJpZ0VuZCBmdXJ0aGVyIGRvd24gdGhvdWdoLCByZWZlcnMgdG8gdGhlIGVuZGlhbm5lc3Mgb2YgdGhlIGltYWdlIGl0c2VsZi5cbiAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYoMCkgIT09IDB4ZmZkOCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGpwZWcnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAyO1xuICAgICAgICAgICAgbGV0IGxvb3BzID0gMDtcbiAgICAgICAgICAgIGxldCBtYXJrZXI7IC8vIEFQUCMgbWFya2VyXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrbG9vcHMgPiAyNTApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRm91bmQgbm8gbWFya2VyIGFmdGVyICR7bG9vcHN9IGxvb3BzIPCfmLVgKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgIT09IDB4ZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgTm90IGEgdmFsaWQgbWFya2VyIGF0IG9mZnNldCAweCR7b2Zmc2V0LnRvU3RyaW5nKDE2KX0sIGZvdW5kOiAweCR7ZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KS50b1N0cmluZygxNil9YCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcmtlciA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE1hcmtlcjogJHttYXJrZXIudG9TdHJpbmcoMTYpfWApO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IDB4ZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIEFQUDIgbWFya2VyICgweGZmZTIpJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmtzIGZvciBpUGhvbmUgOCBQbHVzLCBYLCBhbmQgWFNNYXguIE9yIGFueSBwaG90b3Mgb2YgTVBGIGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gR3JlYXQgd2F5IHRvIHZpc3VhbGl6ZSBpbWFnZSBpbmZvcm1hdGlvbiBpbiBodG1sIGlzIHVzaW5nIEV4aWZ0b29sLiBFLmcuOlxuICAgICAgICAgICAgICAgICAgICAvLyAuL2V4aWZ0b29sLmV4ZSAtaHRtbGR1bXAgLXdhbnRUcmFpbGVyIHBob3RvLmpwZyA+IHBob3RvLmh0bWxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0UHQgPSBvZmZzZXQgKyA0O1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiAgU3RydWN0dXJlIG9mIHRoZSBNUCBGb3JtYXQgSWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiAgT2Zmc2V0IEFkZHIuICB8IENvZGUgKEhleCkgIHwgRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICogICswMCAgICAgICAgICAgICBmZiAgICAgICAgICAgIE1hcmtlciBQcmVmaXggICAgICA8LS0gb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAqICArMDEgICAgICAgICAgICAgZTIgICAgICAgICAgICBBUFAyXG4gICAgICAgICAgICAgICAgICAgICAqICArMDIgICAgICAgICAgICAgI24gICAgICAgICAgICBBUFAyIEZpZWxkIExlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgKiAgKzAzICAgICAgICAgICAgICNuICAgICAgICAgICAgQVBQMiBGaWVsZCBMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICogICswNCAgICAgICAgICAgICA0ZCAgICAgICAgICAgICdNJyAgICAgICAgICAgICAgICA8LS0gZm9ybWF0UHRcbiAgICAgICAgICAgICAgICAgICAgICogICswNSAgICAgICAgICAgICA1MCAgICAgICAgICAgICdQJ1xuICAgICAgICAgICAgICAgICAgICAgKiAgKzA2ICAgICAgICAgICAgIDQ2ICAgICAgICAgICAgJ0YnXG4gICAgICAgICAgICAgICAgICAgICAqICArMDcgICAgICAgICAgICAgMDAgICAgICAgICAgICBOVUxMXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tIHRpZmZPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIoZm9ybWF0UHQpID09PSAweDRkNTA0NjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBNUEYgdGFnLCBzbyB3ZSBzdGFydCBkaWcgb3V0IHN1YiBpbWFnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpZmZPZmZzZXQgPSBmb3JtYXRQdCArIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmlnRW5kOyAvLyBFbmRpYW5uZXNzIGZyb20gVElGRiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIFRJRkYgdmFsaWRpdHkgYW5kIGVuZGlhbm5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDB4NDk0OSBhbmQgMHg0RDREICgnSUknIGFuZCAnTU0nKSBtYXJrcyBMaXR0bGUgRW5kaWFuIGFuZCBCaWcgRW5kaWFuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWdFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0ZDRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlnRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vIHZhbGlkIGVuZGlhbm5lc3MgbWFya2VyIGZvdW5kIGluIFRJRkYgaGVhZGVyJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsICFiaWdFbmQpICE9PSAweDAwMmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdOb3QgdmFsaWQgVElGRiBkYXRhISAobm8gMHgwMDJBIG1hcmtlciknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzIgYml0IG51bWJlciBzdGF0aW5nIHRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIDggQnl0ZSBNUCBIZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIE1QIEluZGV4IElGRCBMZWFzdCBwb3NzaWJsZSB2YWx1ZSBpcyB0aHVzIDggKG1lYW5zIDAgb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBkYXRhVmlldy5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsICFiaWdFbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCB2YWxpZCBUSUZGIGRhdGEhIChGaXJzdCBvZmZzZXQgbGVzcyB0aGFuIDgpJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgYWhlYWQgdG8gTVAgSW5kZXggSUZEXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgd2UncmUgYXQgdGhlIGZpcnN0IElGRCwgc28gZmlyc3RJRkRPZmZzZXQgcG9pbnRzIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNUCBJbmRleCBJRkQgYW5kIG5vdCBNUCBBdHRyaWJ1dGVzIElGRC4gKElmIHdlIHRyeSBleHRyYWN0IGZyb20gYSBzdWIgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmYWlsIHNpbGVudGx5IGhlcmUgZHVlIHRvIHRoaXMgYXNzdW1wdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvdW50ICgyIEJ5dGUpIHwgTVAgSW5kZXggRmllbGRzIGEuay5hLiBNUCBFbnRyaWVzIChjb3VudCAqIDEyIEJ5dGUpIHwgT2Zmc2V0IG9mIE5leHQgSUZEICg0IEJ5dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJTdGFydCA9IHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldDsgLy8gU3RhcnQgb2YgSUZEIChJbWFnZSBGaWxlIERpcmVjdG9yeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZGF0YVZpZXcuZ2V0VWludDE2KGRpclN0YXJ0LCAhYmlnRW5kKTsgLy8gQ291bnQgb2YgTVBFbnRyaWVzICgyIEJ5dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGluZm8gZnJvbSBNUEVudHJpZXMgKHN0YXJ0aW5nIGFmdGVyIENvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cmllc1N0YXJ0ID0gZGlyU3RhcnQgKyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG51bWJlck9mSW1hZ2VzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBlbnRyaWVzU3RhcnQ7IGkgPCBlbnRyaWVzU3RhcnQgKyAxMiAqIGNvdW50OyBpICs9IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBlbnRyeSBpcyAxMiBCeXRlcyBsb25nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgTVAgSW5kZXggSUZEIHRhZ3MsIGhlcmUgd2Ugb25seSB0YWtlIHRhZyAweGIwMDEgPSBOdW1iZXIgb2YgaW1hZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNihpLCAhYmlnRW5kKSA9PT0gMHhiMDAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlZCBpbiBMYXN0IDQgYnl0ZXMgb2YgaXRzIDEyIEJ5dGUgZW50cnkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlck9mSW1hZ2VzID0gZGF0YVZpZXcuZ2V0VWludDMyKGkgKyA4LCAhYmlnRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SUZET2Zmc2V0TGVuID0gNDsgLy8gNCBCeXRlIG9mZnNldCBmaWVsZCB0aGF0IGFwcGVhcnMgYWZ0ZXIgTVAgSW5kZXggSUZEIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IE1QSW1hZ2VMaXN0VmFsUHQgPSBkaXJTdGFydCArIDIgKyBjb3VudCAqIDEyICsgbmV4dElGRE9mZnNldExlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IE1QSW1hZ2VMaXN0VmFsUHQ7IGkgPCBNUEltYWdlTGlzdFZhbFB0ICsgbnVtYmVyT2ZJbWFnZXMgKiAxNjsgaSArPSAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNUFR5cGU6IGRhdGFWaWV3LmdldFVpbnQzMihpLCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZGF0YVZpZXcuZ2V0VWludDMyKGkgKyA0LCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBvZmZzZXQgaXMgc3BlY2lmaWVkIHJlbGF0aXZlIHRvIHRoZSBhZGRyZXNzIG9mIHRoZSBNUCBFbmRpYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGQgaW4gdGhlIE1QIEhlYWRlciwgdW5sZXNzIHRoZSBpbWFnZSBpcyBhIEZpcnN0IEluZGl2aWR1YWwgSW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHdoaWNoIGNhc2UgdGhlIHZhbHVlIG9mIHRoZSBvZmZzZXQgc2hhbGwgYmUgTlVMTCAoMHgwMDAwMDAwMCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQ6IGRhdGFWaWV3LmdldFVpbnQzMihpICsgOCwgIWJpZ0VuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGFudEltYWdlczogZGF0YVZpZXcuZ2V0VWludDMyKGkgKyAxMiwgIWJpZ0VuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGSUk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWltYWdlLmRhdGFPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YU9mZnNldCBpcyAweDAwMDAwMDAwIGZvciBGaXJzdCBJbmRpdmlkdWFsIEltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuaXNGSUkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3RhcnQgPSB0aWZmT2Zmc2V0ICsgaW1hZ2UuZGF0YU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuaXNGSUkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuZW5kID0gaW1hZ2Uuc3RhcnQgKyBpbWFnZS5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlcy5wdXNoKGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0cmFjdE5vbkZJSSAmJiBpbWFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyQmxvYiA9IG5ldyBCbG9iKFtkYXRhVmlld10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGltYWdlIG9mIGltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuaXNGSUkgJiYgIXRoaXMub3B0aW9ucy5leHRyYWN0RklJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCBGSUlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUJsb2IgPSBidWZmZXJCbG9iLnNsaWNlKGltYWdlLnN0YXJ0LCBpbWFnZS5lbmQgKyAxLCAnaW1hZ2UvanBlZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgaW1hZ2VVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGltYWdlQmxvYilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UuaW1nLnNyYyA9IGltYWdlVXJsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZ3MucHVzaChpbWFnZUJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGltZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyICsgZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogRXh0cmFjdHMgWE1QIE1ldGFkYXRhIGFuZCB0aGUgZ2FpbiBtYXAgcmVjb3ZlcnkgaW1hZ2VcbiAqIGZyb20gYSBzaW5nbGUgSlBFRyBmaWxlLlxuICpcbiAqIEBjYXRlZ29yeSBEZWNvZGluZyBGdW5jdGlvbnNcbiAqIEBncm91cCBEZWNvZGluZyBGdW5jdGlvbnNcbiAqIEBwYXJhbSBqcGVnRmlsZSBhbiBgVWludDhBcnJheWAgY29udGFpbmluZyBhbmQgZW5jb2RlZCBKUEVHIGZpbGVcbiAqIEByZXR1cm5zIGFuIHNkciBgVWludDhBcnJheWAgY29tcHJlc3NlZCBpbiBKUEVHLCBhIGdhaW5NYXAgYFVpbnQ4QXJyYXlgIGNvbXByZXNzZWQgaW4gSlBFRyBhbmQgdGhlIFhNUCBwYXJzZWQgWE1QIG1ldGFkYXRhXG4gKiBAdGhyb3dzIEVycm9yIGlmIFhNUCBNZXRhZGF0YSBpcyBub3QgZm91bmRcbiAqIEB0aHJvd3MgRXJyb3IgaWYgR2FpbiBtYXAgaW1hZ2UgaXMgbm90IGZvdW5kXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJ3RocmVlJ1xuICogaW1wb3J0IHsgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICpcbiAqIGNvbnN0IGpwZWdGaWxlID0gYXdhaXQgbmV3IEZpbGVMb2FkZXIoKVxuICogIC5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJylcbiAqICAubG9hZEFzeW5jKCdpbWFnZS5qcGcnKVxuICpcbiAqIGNvbnN0IHsgc2RyLCBnYWluTWFwLCBtZXRhZGF0YSB9ID0gZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyhqcGVnRmlsZSlcbiAqL1xuY29uc3QgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyA9IGFzeW5jIChqcGVnRmlsZSkgPT4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gZXh0cmFjdFhNUChqcGVnRmlsZSk7XG4gICAgaWYgKCFtZXRhZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvcignR2FpbiBtYXAgWE1QIG1ldGFkYXRhIG5vdCBmb3VuZCcpO1xuICAgIGNvbnN0IG1wZkV4dHJhY3RvciA9IG5ldyBNUEZFeHRyYWN0b3IoeyBleHRyYWN0RklJOiB0cnVlLCBleHRyYWN0Tm9uRklJOiB0cnVlIH0pO1xuICAgIGNvbnN0IGltYWdlcyA9IGF3YWl0IG1wZkV4dHJhY3Rvci5leHRyYWN0KGpwZWdGaWxlKTtcbiAgICBpZiAoaW1hZ2VzLmxlbmd0aCAhPT0gMilcbiAgICAgICAgdGhyb3cgbmV3IEdhaW5NYXBOb3RGb3VuZEVycm9yKCdHYWluIG1hcCByZWNvdmVyeSBpbWFnZSBub3QgZm91bmQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZHI6IG5ldyBVaW50OEFycmF5KGF3YWl0IGltYWdlc1swXS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgICAgZ2Fpbk1hcDogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgaW1hZ2VzWzFdLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICBtZXRhZGF0YVxuICAgIH07XG59O1xuXG4vKipcbiAqIHByaXZhdGUgZnVuY3Rpb24sIGFzeW5jIGdldCBpbWFnZSBmcm9tIGJsb2JcbiAqXG4gKiBAcGFyYW0gYmxvYlxuICogQHJldHVybnNcbiAqL1xuY29uc3QgZ2V0SFRNTEltYWdlRnJvbUJsb2IgPSAoYmxvYikgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4geyByZXNvbHZlKGltZyk7IH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXByb21pc2UtcmVqZWN0LWVycm9yc1xuICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiB7IHJlamVjdChlKTsgfTtcbiAgICAgICAgaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFNoYXJlZCBiYXNlIGNsYXNzIGZvciBsb2FkZXJzIHRoYXQgZXh0cmFjdHMgY29tbW9uIGxvZ2ljXG4gKi9cbmNsYXNzIExvYWRlckJhc2VTaGFyZWQgZXh0ZW5kcyBMb2FkZXIge1xuICAgIF9yZW5kZXJlcjtcbiAgICBfcmVuZGVyVGFyZ2V0T3B0aW9ucztcbiAgICBfaW50ZXJuYWxMb2FkaW5nTWFuYWdlcjtcbiAgICBfY29uZmlnO1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgbWFuYWdlcikge1xuICAgICAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAoY29uZmlnLnJlbmRlcmVyKVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBjb25maWcucmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoKTtcbiAgICB9XG4gICAgc2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFJlbmRlclRhcmdldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHByZXBhcmVRdWFkUmVuZGVyZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogQSBSZW5kZXJlciB3YXMgbm90IHBhc3NlZCB0byB0aGlzIExvYWRlciBjb25zdHJ1Y3RvciBvciBpbiBzZXRSZW5kZXJlciwgdGhlIHJlc3VsdCBvZiB0aGlzIExvYWRlciB3aWxsIG5lZWQgdG8gYmUgY29udmVydGVkIHRvIGEgRGF0YSBUZXh0dXJlIHdpdGggdG9EYXRhVGV4dHVyZSgpIGJlZm9yZSB5b3UgY2FuIHVzZSBpdCBpbiB5b3VyIHJlbmRlcmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5fY29uZmlnLmNyZWF0ZU1hdGVyaWFsKHtcbiAgICAgICAgICAgIGdhaW5NYXBNYXg6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgIGdhaW5NYXBNaW46IFswLCAwLCAwXSxcbiAgICAgICAgICAgIGdhbW1hOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICBvZmZzZXRIZHI6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgIG9mZnNldFNkcjogWzEsIDEsIDFdLFxuICAgICAgICAgICAgaGRyQ2FwYWNpdHlNYXg6IDEsXG4gICAgICAgICAgICBoZHJDYXBhY2l0eU1pbjogMCxcbiAgICAgICAgICAgIG1heERpc3BsYXlCb29zdDogMSxcbiAgICAgICAgICAgIGdhaW5NYXA6IG5ldyBUZXh0dXJlKCksXG4gICAgICAgICAgICBzZHI6IG5ldyBUZXh0dXJlKClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuY3JlYXRlUXVhZFJlbmRlcmVyKHtcbiAgICAgICAgICAgIHdpZHRoOiAxNixcbiAgICAgICAgICAgIGhlaWdodDogMTYsXG4gICAgICAgICAgICB0eXBlOiBIYWxmRmxvYXRUeXBlLFxuICAgICAgICAgICAgY29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXG4gICAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICAgIHJlbmRlcmVyOiB0aGlzLl9yZW5kZXJlcixcbiAgICAgICAgICAgIHJlbmRlclRhcmdldE9wdGlvbnM6IHRoaXMuX3JlbmRlclRhcmdldE9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NJbWFnZXMoc2RyQnVmZmVyLCBnYWluTWFwQnVmZmVyLCBpbWFnZU9yaWVudGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGdhaW5NYXBCbG9iID0gZ2Fpbk1hcEJ1ZmZlciA/IG5ldyBCbG9iKFtnYWluTWFwQnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNkckJsb2IgPSBuZXcgQmxvYihbc2RyQnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICAgIGxldCBzZHJJbWFnZTtcbiAgICAgICAgbGV0IGdhaW5NYXBJbWFnZTtcbiAgICAgICAgbGV0IG5lZWRzRmxpcCA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGdhaW5NYXBCbG9iID8gZ2V0SFRNTEltYWdlRnJvbUJsb2IoZ2Fpbk1hcEJsb2IpIDogUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgZ2V0SFRNTEltYWdlRnJvbUJsb2Ioc2RyQmxvYilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgZ2Fpbk1hcEltYWdlID0gcmVzWzBdO1xuICAgICAgICAgICAgc2RySW1hZ2UgPSByZXNbMV07XG4gICAgICAgICAgICBuZWVkc0ZsaXAgPSBpbWFnZU9yaWVudGF0aW9uID09PSAnZmxpcFknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGdhaW5NYXBCbG9iID8gY3JlYXRlSW1hZ2VCaXRtYXAoZ2Fpbk1hcEJsb2IsIHsgaW1hZ2VPcmllbnRhdGlvbjogaW1hZ2VPcmllbnRhdGlvbiB8fCAnZmxpcFknIH0pIDogUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoc2RyQmxvYiwgeyBpbWFnZU9yaWVudGF0aW9uOiBpbWFnZU9yaWVudGF0aW9uIHx8ICdmbGlwWScgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgZ2Fpbk1hcEltYWdlID0gcmVzWzBdO1xuICAgICAgICAgICAgc2RySW1hZ2UgPSByZXNbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2RySW1hZ2UsIGdhaW5NYXBJbWFnZSwgbmVlZHNGbGlwIH07XG4gICAgfVxuICAgIGNyZWF0ZVRleHR1cmVzKHNkckltYWdlLCBnYWluTWFwSW1hZ2UsIG5lZWRzRmxpcCkge1xuICAgICAgICBjb25zdCBnYWluTWFwID0gbmV3IFRleHR1cmUoZ2Fpbk1hcEltYWdlIHx8IG5ldyBJbWFnZURhdGEoMiwgMiksIFVWTWFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsIFJHQkFGb3JtYXQsIFVuc2lnbmVkQnl0ZVR5cGUsIDEsIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgZ2Fpbk1hcC5mbGlwWSA9IG5lZWRzRmxpcDtcbiAgICAgICAgZ2Fpbk1hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHNkciA9IG5ldyBUZXh0dXJlKHNkckltYWdlLCBVVk1hcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIExpbmVhckZpbHRlciwgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCBSR0JBRm9ybWF0LCBVbnNpZ25lZEJ5dGVUeXBlLCAxLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIHNkci5mbGlwWSA9IG5lZWRzRmxpcDtcbiAgICAgICAgc2RyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHsgZ2Fpbk1hcCwgc2RyIH07XG4gICAgfVxuICAgIHVwZGF0ZVF1YWRSZW5kZXJlcihxdWFkUmVuZGVyZXIsIHNkckltYWdlLCBnYWluTWFwLCBzZHIsIG1ldGFkYXRhKSB7XG4gICAgICAgIHF1YWRSZW5kZXJlci53aWR0aCA9IHNkckltYWdlLndpZHRoO1xuICAgICAgICBxdWFkUmVuZGVyZXIuaGVpZ2h0ID0gc2RySW1hZ2UuaGVpZ2h0O1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuZ2Fpbk1hcCA9IGdhaW5NYXA7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5zZHIgPSBzZHI7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYWluTWFwTWluID0gbWV0YWRhdGEuZ2Fpbk1hcE1pbjtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhaW5NYXBNYXggPSBtZXRhZGF0YS5nYWluTWFwTWF4O1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwub2Zmc2V0SGRyID0gbWV0YWRhdGEub2Zmc2V0SGRyO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwub2Zmc2V0U2RyID0gbWV0YWRhdGEub2Zmc2V0U2RyO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuZ2FtbWEgPSBtZXRhZGF0YS5nYW1tYTtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmhkckNhcGFjaXR5TWluID0gbWV0YWRhdGEuaGRyQ2FwYWNpdHlNaW47XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5oZHJDYXBhY2l0eU1heCA9IG1ldGFkYXRhLmhkckNhcGFjaXR5TWF4O1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwubWF4RGlzcGxheUJvb3N0ID0gTWF0aC5wb3coMiwgbWV0YWRhdGEuaGRyQ2FwYWNpdHlNYXgpO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgR2Fpbk1hcE5vdEZvdW5kRXJyb3IgYXMgRywgTG9hZGVyQmFzZVNoYXJlZCBhcyBMLCBNUEZFeHRyYWN0b3IgYXMgTSwgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yIGFzIFgsIGV4dHJhY3RYTVAgYXMgYSwgY3JlYXRlRGVjb2RlRnVuY3Rpb24gYXMgYywgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyBhcyBlIH07XG4iXSwibmFtZXMiOlsiU1JHQkNvbG9yU3BhY2UiLCJMaW5lYXJTUkdCQ29sb3JTcGFjZSIsIkhhbGZGbG9hdFR5cGUiLCJMb2FkZXIiLCJMb2FkaW5nTWFuYWdlciIsIlRleHR1cmUiLCJVVk1hcHBpbmciLCJDbGFtcFRvRWRnZVdyYXBwaW5nIiwiTGluZWFyRmlsdGVyIiwiTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyIiwiUkdCQUZvcm1hdCIsIlVuc2lnbmVkQnl0ZVR5cGUiLCJjcmVhdGVEZWNvZGVGdW5jdGlvbiIsImNvbmZpZyIsInBhcmFtcyIsInNkciIsImdhaW5NYXAiLCJyZW5kZXJlciIsImNvbG9yU3BhY2UiLCJjb25zb2xlIiwid2FybiIsIm5lZWRzVXBkYXRlIiwibWF0ZXJpYWwiLCJjcmVhdGVNYXRlcmlhbCIsInF1YWRSZW5kZXJlciIsImNyZWF0ZVF1YWRSZW5kZXJlciIsIndpZHRoIiwiaW1hZ2UiLCJoZWlnaHQiLCJ0eXBlIiwicmVuZGVyVGFyZ2V0T3B0aW9ucyIsIkdhaW5NYXBOb3RGb3VuZEVycm9yIiwiRXJyb3IiLCJYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IiLCJnZXRYTUxWYWx1ZSIsInhtbCIsInRhZyIsImRlZmF1bHRWYWx1ZSIsImF0dHJpYnV0ZU1hdGNoIiwiUmVnRXhwIiwiZXhlYyIsInRhZ01hdGNoIiwibGlWYWx1ZXMiLCJtYXRjaCIsImxlbmd0aCIsIm1hcCIsInYiLCJyZXBsYWNlIiwidHJpbSIsInVuZGVmaW5lZCIsImV4dHJhY3RYTVAiLCJpbnB1dCIsInN0ciIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwidG9TdHJpbmciLCJzdGFydCIsImluZGV4T2YiLCJlbmQiLCJ4bXBCbG9jayIsInNsaWNlIiwiZ2Fpbk1hcE1pbiIsImdhaW5NYXBNYXgiLCJnYW1tYSIsIm9mZnNldFNEUiIsIm9mZnNldEhEUiIsImhkckNhcGFjaXR5TWluTWF0Y2giLCJoZHJDYXBhY2l0eU1pbiIsImhkckNhcGFjaXR5TWF4TWF0Y2giLCJoZHJDYXBhY2l0eU1heCIsIkFycmF5IiwiaXNBcnJheSIsInBhcnNlRmxvYXQiLCJvZmZzZXRTZHIiLCJvZmZzZXRIZHIiLCJlIiwiTVBGRXh0cmFjdG9yIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiZGVidWciLCJleHRyYWN0RklJIiwiZXh0cmFjdE5vbkZJSSIsImV4dHJhY3QiLCJpbWFnZUFycmF5QnVmZmVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJkYXRhVmlldyIsIkRhdGFWaWV3IiwiYnVmZmVyIiwiZ2V0VWludDE2IiwiYnl0ZUxlbmd0aCIsIm9mZnNldCIsImxvb3BzIiwibWFya2VyIiwiZ2V0VWludDgiLCJsb2ciLCJmb3JtYXRQdCIsImdldFVpbnQzMiIsInRpZmZPZmZzZXQiLCJiaWdFbmQiLCJmaXJzdElGRE9mZnNldCIsImRpclN0YXJ0IiwiY291bnQiLCJlbnRyaWVzU3RhcnQiLCJudW1iZXJPZkltYWdlcyIsImkiLCJuZXh0SUZET2Zmc2V0TGVuIiwiTVBJbWFnZUxpc3RWYWxQdCIsImltYWdlcyIsIk1QVHlwZSIsInNpemUiLCJkYXRhT2Zmc2V0IiwiZGVwZW5kYW50SW1hZ2VzIiwiaXNGSUkiLCJwdXNoIiwiYnVmZmVyQmxvYiIsIkJsb2IiLCJpbWdzIiwiaW1hZ2VCbG9iIiwiZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyIsImpwZWdGaWxlIiwibWV0YWRhdGEiLCJtcGZFeHRyYWN0b3IiLCJVaW50OEFycmF5IiwiYXJyYXlCdWZmZXIiLCJnZXRIVE1MSW1hZ2VGcm9tQmxvYiIsImJsb2IiLCJpbWciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJvbmxvYWQiLCJvbmVycm9yIiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiTG9hZGVyQmFzZVNoYXJlZCIsIm1hbmFnZXIiLCJfY29uZmlnIiwiX3JlbmRlcmVyIiwiX2ludGVybmFsTG9hZGluZ01hbmFnZXIiLCJzZXRSZW5kZXJlciIsInNldFJlbmRlclRhcmdldE9wdGlvbnMiLCJfcmVuZGVyVGFyZ2V0T3B0aW9ucyIsInByZXBhcmVRdWFkUmVuZGVyZXIiLCJtYXhEaXNwbGF5Qm9vc3QiLCJwcm9jZXNzSW1hZ2VzIiwic2RyQnVmZmVyIiwiZ2Fpbk1hcEJ1ZmZlciIsImltYWdlT3JpZW50YXRpb24iLCJnYWluTWFwQmxvYiIsInNkckJsb2IiLCJzZHJJbWFnZSIsImdhaW5NYXBJbWFnZSIsIm5lZWRzRmxpcCIsImNyZWF0ZUltYWdlQml0bWFwIiwicmVzIiwiYWxsIiwiY3JlYXRlVGV4dHVyZXMiLCJJbWFnZURhdGEiLCJmbGlwWSIsInVwZGF0ZVF1YWRSZW5kZXJlciIsIk1hdGgiLCJwb3ciLCJHIiwiTCIsIk0iLCJYIiwiYSIsImMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/Loader-BZcKUVaX.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Y5tm-R3m.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Y5tm-R3m.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ QuadRenderer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.2.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */ \nconst getBufferForType = (type, width, height)=>{\n    let out;\n    switch(type){\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error(\"Unsupported data type\");\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */ const canReadPixels = (type, renderer, camera, renderTargetOptions)=>{\n    if (_canReadPixelsResult !== undefined) return _canReadPixelsResult;\n    const testRT = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n        color: 0xffffff\n    }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */ class QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */ constructor(options){\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n     * Renders the input texture using the specified material\n     */ this.render = ()=>{\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            } catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type,\n            colorSpace: this._colorSpace,\n            anisotropy: options.renderTargetOptions?.anisotropy !== undefined ? options.renderTargetOptions?.anisotropy : 1,\n            generateMipmaps: options.renderTargetOptions?.generateMipmaps !== undefined ? options.renderTargetOptions?.generateMipmaps : false,\n            magFilter: options.renderTargetOptions?.magFilter !== undefined ? options.renderTargetOptions?.magFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            minFilter: options.renderTargetOptions?.minFilter !== undefined ? options.renderTargetOptions?.minFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            samples: options.renderTargetOptions?.samples !== undefined ? options.renderTargetOptions?.samples : undefined,\n            wrapS: options.renderTargetOptions?.wrapS !== undefined ? options.renderTargetOptions?.wrapS : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n            wrapT: options.renderTargetOptions?.wrapT !== undefined ? options.renderTargetOptions?.wrapT : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        } else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this._camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch(this._type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    alternativeType = this._renderer.extensions.has(\"EXT_color_buffer_float\") ? three__WEBPACK_IMPORTED_MODULE_0__.FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${three__WEBPACK_IMPORTED_MODULE_0__.FloatType}`);\n                this._type = alternativeType;\n            } else {\n                this._supportsReadPixels = false;\n                console.warn(\"This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown\");\n            }\n        }\n        this._quad = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = options.renderTargetOptions?.mapping !== undefined ? options.renderTargetOptions?.mapping : three__WEBPACK_IMPORTED_MODULE_0__.UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */ static instantiateRenderer() {\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */ toArray() {\n        if (!this._supportsReadPixels) throw new Error(\"Can't read pixels in this browser\");\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @param options options\n     * @returns\n     */ toDataTexture(options) {\n        const returnValue = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(// fixed values\n        this.toArray(), this.width, this.height, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, this._type, // user values\n        options?.mapping || three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, options?.wrapS || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, options?.wrapT || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, options?.magFilter || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, options?.minFilter || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, options?.anisotropy || 1, // fixed value\n        three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = options?.generateMipmaps !== undefined ? options?.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */ disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */ dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach((v)=>{\n                if (v.value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach((value)=>{\n            if (value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */ get width() {\n        return this._width;\n    }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */ get height() {\n        return this._height;\n    }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */ get renderer() {\n        return this._renderer;\n    }\n    /**\n     * The `WebGLRenderTarget` used.\n     */ get renderTarget() {\n        return this._renderTarget;\n    }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n    // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */ get material() {\n        return this._material;\n    }\n    /**\n     *\n     */ get type() {\n        return this._type;\n    }\n    get colorSpace() {\n        return this._colorSpace;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9RdWFkUmVuZGVyZXItWTV0bS1SM20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBRTRVO0FBRTdVLE1BQU1zQixtQkFBbUIsQ0FBQ0MsTUFBTUMsT0FBT0M7SUFDbkMsSUFBSUM7SUFDSixPQUFRSDtRQUNKLEtBQUtGLG1EQUFnQkE7WUFDakJLLE1BQU0sSUFBSUMsa0JBQWtCSCxRQUFRQyxTQUFTO1lBQzdDO1FBQ0osS0FBS3JCLGdEQUFhQTtZQUNkc0IsTUFBTSxJQUFJRSxZQUFZSixRQUFRQyxTQUFTO1lBQ3ZDO1FBQ0osS0FBS0wsa0RBQWVBO1lBQ2hCTSxNQUFNLElBQUlHLFlBQVlMLFFBQVFDLFNBQVM7WUFDdkM7UUFDSixLQUFLTiwyQ0FBUUE7WUFDVE8sTUFBTSxJQUFJSSxVQUFVTixRQUFRQyxTQUFTO1lBQ3JDO1FBQ0osS0FBS1AsNENBQVNBO1lBQ1ZRLE1BQU0sSUFBSUssV0FBV1AsUUFBUUMsU0FBUztZQUN0QztRQUNKLEtBQUtSLDBDQUFPQTtZQUNSUyxNQUFNLElBQUlNLFdBQVdSLFFBQVFDLFNBQVM7WUFDdEM7UUFDSixLQUFLcEIsNENBQVNBO1lBQ1ZxQixNQUFNLElBQUlPLGFBQWFULFFBQVFDLFNBQVM7WUFDeEM7UUFDSjtZQUNJLE1BQU0sSUFBSVMsTUFBTTtJQUN4QjtJQUNBLE9BQU9SO0FBQ1g7QUFDQSxJQUFJUztBQUNKOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsTUFBTUMsZ0JBQWdCLENBQUNiLE1BQU1jLFVBQVVDLFFBQVFDO0lBQzNDLElBQUlKLHlCQUF5QkssV0FDekIsT0FBT0w7SUFDWCxNQUFNTSxTQUFTLElBQUlqQyxvREFBaUJBLENBQUMsR0FBRyxHQUFHK0I7SUFDM0NGLFNBQVNLLGVBQWUsQ0FBQ0Q7SUFDekIsTUFBTUUsT0FBTyxJQUFJckMsdUNBQUlBLENBQUMsSUFBSUMsZ0RBQWFBLElBQUksSUFBSVMsb0RBQWlCQSxD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QUNELElBQUl3QixXQUFXO1FBQUUsT0FBTyxJQUFJLENBQUMyQixTQUFTO0lBQUU7SUFDeEM7O0tBRUMsR0FDRCxJQUFJckQsT0FBTztRQUFFLE9BQU8sSUFBSSxDQUFDdUMsS0FBSztJQUFFO0lBQ2hDLElBQUlFLGFBQWE7UUFBRSxPQUFPLElBQUksQ0FBQ0QsV0FBVztJQUFFO0FBQ2hEO0FBRTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pdmVyc2l0eS15ZWFycy8uL25vZGVfbW9kdWxlcy9AbW9ub2dyaWQvZ2Fpbm1hcC1qcy9kaXN0L1F1YWRSZW5kZXJlci1ZNXRtLVIzbS5qcz80YzZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vbm9ncmlkL2dhaW5tYXAtanMgdjMuMi4wXG4gKiBXaXRoIOKdpO+4jywgYnkgTU9OT0dSSUQgPGdhaW5tYXBAbW9ub2dyaWQuY29tPlxuICovXG5cbmltcG9ydCB7IENsYW1wVG9FZGdlV3JhcHBpbmcsIExpbmVhckZpbHRlciwgU2NlbmUsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBNZXNoLCBQbGFuZUdlb21ldHJ5LCBXZWJHTFJlbmRlclRhcmdldCwgUkdCQUZvcm1hdCwgVVZNYXBwaW5nLCBXZWJHTFJlbmRlcmVyLCBEYXRhVGV4dHVyZSwgTGluZWFyU1JHQkNvbG9yU3BhY2UsIFNoYWRlck1hdGVyaWFsLCBUZXh0dXJlLCBNZXNoQmFzaWNNYXRlcmlhbCwgSW50VHlwZSwgU2hvcnRUeXBlLCBCeXRlVHlwZSwgVW5zaWduZWRJbnRUeXBlLCBVbnNpZ25lZEJ5dGVUeXBlIH0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCBnZXRCdWZmZXJGb3JUeXBlID0gKHR5cGUsIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBsZXQgb3V0O1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFVuc2lnbmVkQnl0ZVR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgVWludDE2QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFVuc2lnbmVkSW50VHlwZTpcbiAgICAgICAgICAgIG91dCA9IG5ldyBVaW50MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQnl0ZVR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgSW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTaG9ydFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgSW50MTZBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW50VHlwZTpcbiAgICAgICAgICAgIG91dCA9IG5ldyBJbnQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xubGV0IF9jYW5SZWFkUGl4ZWxzUmVzdWx0O1xuLyoqXG4gKiBUZXN0IGlmIHRoaXMgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBjYW4gY29ycmVjdGx5IHJlYWQgcGl4ZWxzIGZyb20gdGhlIHNwZWNpZmllZFxuICogUmVuZGVyIHRhcmdldCB0eXBlLlxuICpcbiAqIFJ1bnMgb25seSBvbmNlXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEBwYXJhbSByZW5kZXJlclxuICogQHBhcmFtIGNhbWVyYVxuICogQHBhcmFtIHJlbmRlclRhcmdldE9wdGlvbnNcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IGNhblJlYWRQaXhlbHMgPSAodHlwZSwgcmVuZGVyZXIsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0T3B0aW9ucykgPT4ge1xuICAgIGlmIChfY2FuUmVhZFBpeGVsc1Jlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gX2NhblJlYWRQaXhlbHNSZXN1bHQ7XG4gICAgY29uc3QgdGVzdFJUID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHJlbmRlclRhcmdldE9wdGlvbnMpO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0ZXN0UlQpO1xuICAgIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChuZXcgUGxhbmVHZW9tZXRyeSgpLCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZmYgfSkpO1xuICAgIHJlbmRlcmVyLnJlbmRlcihtZXNoLCBjYW1lcmEpO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICBjb25zdCBvdXQgPSBnZXRCdWZmZXJGb3JUeXBlKHR5cGUsIHRlc3RSVC53aWR0aCwgdGVzdFJULmhlaWdodCk7XG4gICAgcmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVscyh0ZXN0UlQsIDAsIDAsIHRlc3RSVC53aWR0aCwgdGVzdFJULmhlaWdodCwgb3V0KTtcbiAgICB0ZXN0UlQuZGlzcG9zZSgpO1xuICAgIG1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIG1lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgIF9jYW5SZWFkUGl4ZWxzUmVzdWx0ID0gb3V0WzBdICE9PSAwO1xuICAgIHJldHVybiBfY2FuUmVhZFBpeGVsc1Jlc3VsdDtcbn07XG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgdXNlZCBmb3IgcmVuZGVyaW5nIGEgdGV4dHVyZSB3aXRoIGEgbWF0ZXJpYWxcbiAqXG4gKiBAY2F0ZWdvcnkgQ29yZVxuICogQGdyb3VwIENvcmVcbiAqL1xuY2xhc3MgUXVhZFJlbmRlcmVyIHtcbiAgICBfcmVuZGVyZXI7XG4gICAgX3JlbmRlcmVySXNEaXNwb3NhYmxlID0gZmFsc2U7XG4gICAgX21hdGVyaWFsO1xuICAgIF9zY2VuZTtcbiAgICBfY2FtZXJhO1xuICAgIF9xdWFkO1xuICAgIF9yZW5kZXJUYXJnZXQ7XG4gICAgX3dpZHRoO1xuICAgIF9oZWlnaHQ7XG4gICAgX3R5cGU7XG4gICAgX2NvbG9yU3BhY2U7XG4gICAgX3N1cHBvcnRzUmVhZFBpeGVscyA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBRdWFkUmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFBhcmFtZXRlcnMgZm9yIHRoaXMgUXVhZFJlbmRlcmVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl93aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICB0aGlzLl90eXBlID0gb3B0aW9ucy50eXBlO1xuICAgICAgICB0aGlzLl9jb2xvclNwYWNlID0gb3B0aW9ucy5jb2xvclNwYWNlO1xuICAgICAgICBjb25zdCBydE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLyBmaXhlZCBvcHRpb25zXG4gICAgICAgICAgICBmb3JtYXQ6IFJHQkFGb3JtYXQsXG4gICAgICAgICAgICBkZXB0aEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICBzdGVuY2lsQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIHVzZXIgb3B0aW9uc1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fdHlwZSwgLy8gc2V0IGluIGNsYXNzIHByb3BlcnR5XG4gICAgICAgICAgICBjb2xvclNwYWNlOiB0aGlzLl9jb2xvclNwYWNlLCAvLyBzZXQgaW4gY2xhc3MgcHJvcGVydHlcbiAgICAgICAgICAgIGFuaXNvdHJvcHk6IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8uYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5hbmlzb3Ryb3B5IDogMSxcbiAgICAgICAgICAgIGdlbmVyYXRlTWlwbWFwczogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8uZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2UsXG4gICAgICAgICAgICBtYWdGaWx0ZXI6IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/Lm1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcixcbiAgICAgICAgICAgIG1pbkZpbHRlcjogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ubWluRmlsdGVyIDogTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgc2FtcGxlczogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5zYW1wbGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/LnNhbXBsZXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3cmFwUzogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy53cmFwUyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy53cmFwUyA6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gICAgICAgICAgICB3cmFwVDogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy53cmFwVCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmdcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xuICAgICAgICBpZiAob3B0aW9ucy5yZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBRdWFkUmVuZGVyZXIuaW5zdGFudGlhdGVSZW5kZXJlcigpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NjZW5lID0gbmV3IFNjZW5lKCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAxMCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYS5sZWZ0ID0gLTAuNTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnJpZ2h0ID0gMC41O1xuICAgICAgICB0aGlzLl9jYW1lcmEudG9wID0gMC41O1xuICAgICAgICB0aGlzLl9jYW1lcmEuYm90dG9tID0gLTAuNTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgaWYgKCFjYW5SZWFkUGl4ZWxzKHRoaXMuX3R5cGUsIHRoaXMuX3JlbmRlcmVyLCB0aGlzLl9jYW1lcmEsIHJ0T3B0aW9ucykpIHtcbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGl2ZVR5cGU7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlVHlwZSA9IHRoaXMuX3JlbmRlcmVyLmV4dGVuc2lvbnMuaGFzKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JykgPyBGbG9hdFR5cGUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsdGVybmF0aXZlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIHBpeGVscyBmcm9tICR7dGhpcy5fdHlwZX0gUmVuZGVyVGFyZ2V0cywgc3dpdGNoaW5nIHRvICR7RmxvYXRUeXBlfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBhbHRlcm5hdGl2ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdXBwb3J0c1JlYWRQaXhlbHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgYnJvd3NlciBkb3Mgbm90IHN1cHBvcnQgdG9BcnJheSBvciB0b0RhdGFUZXh0dXJlLCBjYWxscyB0byB0aG9zZSBtZXRob2RzIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIHRocm93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3F1YWQgPSBuZXcgTWVzaChuZXcgUGxhbmVHZW9tZXRyeSgpLCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuX3F1YWQuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgICAgIHRoaXMuX3NjZW5lLmFkZCh0aGlzLl9xdWFkKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBydE9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQudGV4dHVyZS5tYXBwaW5nID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5tYXBwaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/Lm1hcHBpbmcgOiBVVk1hcHBpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIHRlbXBvcmFyeSByZW5kZXJlclxuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5zdGFudGlhdGVSZW5kZXJlcigpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpO1xuICAgICAgICByZW5kZXJlci5zZXRTaXplKDEyOCwgMTI4KTtcbiAgICAgICAgLy8gcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlXG4gICAgICAgIC8vIHJlbmRlcmVyLnRvbmVNYXBwaW5nID0gTGluZWFyVG9uZU1hcHBpbmdcbiAgICAgICAgLy8gcmVuZGVyZXIuZGVidWcuY2hlY2tTaGFkZXJFcnJvcnMgPSBmYWxzZVxuICAgICAgICAvLyB0aGlzLl9yZW5kZXJlcklzRGlzcG9zYWJsZSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBpbnB1dCB0ZXh0dXJlIHVzaW5nIHRoZSBzcGVjaWZpZWQgbWF0ZXJpYWxcbiAgICAgKi9cbiAgICByZW5kZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLl9yZW5kZXJUYXJnZXQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKHRoaXMuX3NjZW5lLCB0aGlzLl9jYW1lcmEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9idGFpbnMgYSBCdWZmZXIgY29udGFpbmluZyB0aGUgcmVuZGVyZWQgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGJyb3dzZXIgY2Fubm90IHJlYWQgcGl4ZWxzIGZyb20gdGhpcyBSZW5kZXJUYXJnZXQgdHlwZS5cbiAgICAgKiBAcmV0dXJucyBhIFR5cGVkQXJyYXkgY29udGFpbmluZyBSR0JBIHZhbHVlcyBmcm9tIHRoaXMgcmVuZGVyZXJcbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N1cHBvcnRzUmVhZFBpeGVscylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCByZWFkIHBpeGVscyBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gZ2V0QnVmZmVyRm9yVHlwZSh0aGlzLl90eXBlLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVscyh0aGlzLl9yZW5kZXJUYXJnZXQsIDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmVhZFBpeGVsIG9wZXJhdGlvbiBpbiB0aGUgcmVuZGVyVGFyZ2V0XG4gICAgICogYW5kIHJldHVybnMgYSBEYXRhVGV4dHVyZSBjb250YWluaW5nIHRoZSByZWFkIGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHRvRGF0YVRleHR1cmUob3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG5ldyBEYXRhVGV4dHVyZShcbiAgICAgICAgLy8gZml4ZWQgdmFsdWVzXG4gICAgICAgIHRoaXMudG9BcnJheSgpLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgUkdCQUZvcm1hdCwgdGhpcy5fdHlwZSwgXG4gICAgICAgIC8vIHVzZXIgdmFsdWVzXG4gICAgICAgIG9wdGlvbnM/Lm1hcHBpbmcgfHwgVVZNYXBwaW5nLCBvcHRpb25zPy53cmFwUyB8fCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBvcHRpb25zPy53cmFwVCB8fCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBvcHRpb25zPy5tYWdGaWx0ZXIgfHwgTGluZWFyRmlsdGVyLCBvcHRpb25zPy5taW5GaWx0ZXIgfHwgTGluZWFyRmlsdGVyLCBvcHRpb25zPy5hbmlzb3Ryb3B5IHx8IDEsIFxuICAgICAgICAvLyBmaXhlZCB2YWx1ZVxuICAgICAgICBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIC8vIHNldCB0aGlzIGFmdGVyd2FyZHMsIHdlIGNhbid0IHNldCBpdCBpbiBjb25zdHJ1Y3RvclxuICAgICAgICByZXR1cm5WYWx1ZS5nZW5lcmF0ZU1pcG1hcHMgPSBvcHRpb25zPy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnM/LmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHVzaW5nIGEgZGlzcG9zYWJsZSByZW5kZXJlciwgaXQgd2lsbCBkaXNwb3NlIGl0LlxuICAgICAqL1xuICAgIGRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJlcklzRGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZm9yY2VDb250ZXh0TG9zcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgZGlzcG9zZSBvZiAqKmFsbCoqIGFzc2V0cyB1c2VkIGJ5IHRoaXMgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXNwb3NlUmVuZGVyVGFyZ2V0IHdpbGwgZGlzcG9zZSBvZiB0aGUgcmVuZGVyVGFyZ2V0IHdoaWNoIHdpbGwgbm90IGJlIHVzYWJsZSBsYXRlclxuICAgICAqIHNldCB0aGlzIHRvIHRydWUgaWYgeW91IHBhc3NlZCB0aGUgYHJlbmRlclRhcmdldC50ZXh0dXJlYCB0byBhIGBQTVJFTUdlbmVyYXRvcmBcbiAgICAgKiBvciBhcmUgb3RoZXJ3aXNlIGRvbmUgd2l0aCBpdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBsb2FkZXIgPSBuZXcgSERSSlBHTG9hZGVyKHJlbmRlcmVyKVxuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBlZycpXG4gICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KSApXG4gICAgICogLy8gRE8gTk9UIGRpc3Bvc2UgdGhlIHJlbmRlclRhcmdldCBoZXJlLFxuICAgICAqIC8vIGl0IGlzIHVzZWQgZGlyZWN0bHkgaW4gdGhlIG1hdGVyaWFsXG4gICAgICogcmVzdWx0LmRpc3Bvc2UoKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGxvYWRlciA9IG5ldyBIRFJKUEdMb2FkZXIocmVuZGVyZXIpXG4gICAgICogY29uc3QgcG1yZW1HZW5lcmF0b3IgPSBuZXcgUE1SRU1HZW5lcmF0b3IoIHJlbmRlcmVyICk7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGVnJylcbiAgICAgKiBjb25zdCBlbnZNYXAgPSBwbXJlbUdlbmVyYXRvci5mcm9tRXF1aXJlY3Rhbmd1bGFyKHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSlcbiAgICAgKiBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7IGVudk1hcCB9KSApXG4gICAgICogLy8gcmVuZGVyVGFyZ2V0IGNhbiBiZSBkaXNwb3NlZCBoZXJlXG4gICAgICogLy8gYmVjYXVzZSBpdCB3YXMgdXNlZCB0byBnZW5lcmF0ZSBhIFBNUkVNIHRleHR1cmVcbiAgICAgKiByZXN1bHQuZGlzcG9zZSh0cnVlKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRpc3Bvc2UoZGlzcG9zZVJlbmRlclRhcmdldCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgIGlmIChkaXNwb3NlUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzcG9zZSBzaGFkZXIgbWF0ZXJpYWwgdGV4dHVyZSB1bmlmb3Jtc1xuICAgICAgICBpZiAodGhpcy5tYXRlcmlhbCBpbnN0YW5jZW9mIFNoYWRlck1hdGVyaWFsKSB7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMubWF0ZXJpYWwudW5pZm9ybXMpLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHYudmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKVxuICAgICAgICAgICAgICAgICAgICB2LnZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpc3Bvc2Ugb3RoZXIgbWF0ZXJpYWwgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMubWF0ZXJpYWwpLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGV4dHVyZSlcbiAgICAgICAgICAgICAgICB2YWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fcXVhZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fd2lkdGg7IH1cbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LnNldFNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLl9oZWlnaHQ7IH1cbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQuc2V0U2l6ZSh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlbmRlcmVyIHVzZWRcbiAgICAgKi9cbiAgICBnZXQgcmVuZGVyZXIoKSB7IHJldHVybiB0aGlzLl9yZW5kZXJlcjsgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgV2ViR0xSZW5kZXJUYXJnZXRgIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHJlbmRlclRhcmdldCgpIHsgcmV0dXJuIHRoaXMuX3JlbmRlclRhcmdldDsgfVxuICAgIHNldCByZW5kZXJUYXJnZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWUud2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlLmhlaWdodDtcbiAgICAgICAgLy8gdGhpcy5fdHlwZSA9IHZhbHVlLnRleHR1cmUudHlwZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYE1hdGVyaWFsYCB1c2VkLlxuICAgICAqL1xuICAgIGdldCBtYXRlcmlhbCgpIHsgcmV0dXJuIHRoaXMuX21hdGVyaWFsOyB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3R5cGU7IH1cbiAgICBnZXQgY29sb3JTcGFjZSgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yU3BhY2U7IH1cbn1cblxuZXhwb3J0IHsgUXVhZFJlbmRlcmVyIGFzIFEgfTtcbiJdLCJuYW1lcyI6WyJDbGFtcFRvRWRnZVdyYXBwaW5nIiwiTGluZWFyRmlsdGVyIiwiU2NlbmUiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJIYWxmRmxvYXRUeXBlIiwiRmxvYXRUeXBlIiwiTWVzaCIsIlBsYW5lR2VvbWV0cnkiLCJXZWJHTFJlbmRlclRhcmdldCIsIlJHQkFGb3JtYXQiLCJVVk1hcHBpbmciLCJXZWJHTFJlbmRlcmVyIiwiRGF0YVRleHR1cmUiLCJMaW5lYXJTUkdCQ29sb3JTcGFjZSIsIlNoYWRlck1hdGVyaWFsIiwiVGV4dHVyZSIsIk1lc2hCYXNpY01hdGVyaWFsIiwiSW50VHlwZSIsIlNob3J0VHlwZSIsIkJ5dGVUeXBlIiwiVW5zaWduZWRJbnRUeXBlIiwiVW5zaWduZWRCeXRlVHlwZSIsImdldEJ1ZmZlckZvclR5cGUiLCJ0eXBlIiwid2lkdGgiLCJoZWlnaHQiLCJvdXQiLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkVycm9yIiwiX2NhblJlYWRQaXhlbHNSZXN1bHQiLCJjYW5SZWFkUGl4ZWxzIiwicmVuZGVyZXIiLCJjYW1lcmEiLCJyZW5kZXJUYXJnZXRPcHRpb25zIiwidW5kZWZpbmVkIiwidGVzdFJUIiwic2V0UmVuZGVyVGFyZ2V0IiwibWVzaCIsImNvbG9yIiwicmVuZGVyIiwicmVhZFJlbmRlclRhcmdldFBpeGVscyIsImRpc3Bvc2UiLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiUXVhZFJlbmRlcmVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX3JlbmRlcmVySXNEaXNwb3NhYmxlIiwiX3N1cHBvcnRzUmVhZFBpeGVscyIsIl9yZW5kZXJlciIsIl9yZW5kZXJUYXJnZXQiLCJfc2NlbmUiLCJfY2FtZXJhIiwiZSIsIl93aWR0aCIsIl9oZWlnaHQiLCJfdHlwZSIsIl9jb2xvclNwYWNlIiwiY29sb3JTcGFjZSIsInJ0T3B0aW9ucyIsImZvcm1hdCIsImRlcHRoQnVmZmVyIiwic3RlbmNpbEJ1ZmZlciIsImFuaXNvdHJvcHkiLCJnZW5lcmF0ZU1pcG1hcHMiLCJtYWdGaWx0ZXIiLCJtaW5GaWx0ZXIiLCJzYW1wbGVzIiwid3JhcFMiLCJ3cmFwVCIsIl9tYXRlcmlhbCIsImluc3RhbnRpYXRlUmVuZGVyZXIiLCJwb3NpdGlvbiIsInNldCIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJhbHRlcm5hdGl2ZVR5cGUiLCJleHRlbnNpb25zIiwiaGFzIiwiY29uc29sZSIsIndhcm4iLCJfcXVhZCIsImNvbXB1dGVCb3VuZGluZ0JveCIsImFkZCIsInRleHR1cmUiLCJtYXBwaW5nIiwic2V0U2l6ZSIsInRvQXJyYXkiLCJ0b0RhdGFUZXh0dXJlIiwicmV0dXJuVmFsdWUiLCJkaXNwb3NlT25EZW1hbmRSZW5kZXJlciIsImZvcmNlQ29udGV4dExvc3MiLCJkaXNwb3NlUmVuZGVyVGFyZ2V0IiwicmVuZGVyVGFyZ2V0IiwiT2JqZWN0IiwidmFsdWVzIiwidW5pZm9ybXMiLCJmb3JFYWNoIiwidiIsInZhbHVlIiwiUSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Y5tm-R3m.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/decode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GainMapDecoderMaterial: () => (/* binding */ GainMapDecoderMaterial),\n/* harmony export */   GainMapLoader: () => (/* binding */ GainMapLoader),\n/* harmony export */   GainMapNotFoundError: () => (/* reexport safe */ _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   HDRJPGLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   JPEGRLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   LoaderBaseShared: () => (/* reexport safe */ _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   MPFExtractor: () => (/* reexport safe */ _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   QuadRenderer: () => (/* reexport safe */ _QuadRenderer_Y5tm_R3m_js__WEBPACK_IMPORTED_MODULE_3__.Q),\n/* harmony export */   XMPMetadataNotFoundError: () => (/* reexport safe */ _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   createDecodeFunction: () => (/* reexport safe */ _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   extractGainmapFromJPEG: () => (/* reexport safe */ _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   extractXMP: () => (/* reexport safe */ _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.a)\n/* harmony export */ });\n/* harmony import */ var _QuadRenderer_Y5tm_R3m_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QuadRenderer-Y5tm-R3m.js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Y5tm-R3m.js\");\n/* harmony import */ var _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Loader-BZcKUVaX.js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/Loader-BZcKUVaX.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.2.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */ \n\n\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */ class GainMapDecoderMaterial extends three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial {\n    /**\n     *\n     * @param params\n     */ constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }){\n        super({\n            name: \"GainMapDecoderMaterial\",\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: {\n                    value: sdr\n                },\n                gainMap: {\n                    value: gainMap\n                },\n                gamma: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])\n                },\n                offsetHdr: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(offsetHdr)\n                },\n                offsetSdr: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(offsetSdr)\n                },\n                gainMapMin: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(gainMapMin)\n                },\n                gainMapMax: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(gainMapMax)\n                },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_1__.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() {\n        return this.uniforms.sdr.value;\n    }\n    set sdr(value) {\n        this.uniforms.sdr.value = value;\n    }\n    get gainMap() {\n        return this.uniforms.gainMap.value;\n    }\n    set gainMap(value) {\n        this.uniforms.gainMap.value = value;\n    }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */ get offsetHdr() {\n        return this.uniforms.offsetHdr.value.toArray();\n    }\n    set offsetHdr(value) {\n        this.uniforms.offsetHdr.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */ get offsetSdr() {\n        return this.uniforms.offsetSdr.value.toArray();\n    }\n    set offsetSdr(value) {\n        this.uniforms.offsetSdr.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */ get gainMapMin() {\n        return this.uniforms.gainMapMin.value.toArray();\n    }\n    set gainMapMin(value) {\n        this.uniforms.gainMapMin.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */ get gainMapMax() {\n        return this.uniforms.gainMapMax.value.toArray();\n    }\n    set gainMapMax(value) {\n        this.uniforms.gainMapMax.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */ get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [\n            1 / g.x,\n            1 / g.y,\n            1 / g.z\n        ];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */ get hdrCapacityMin() {\n        return this._hdrCapacityMin;\n    }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */ get hdrCapacityMax() {\n        return this._hdrCapacityMax;\n    }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */ get maxDisplayBoost() {\n        return this._maxDisplayBoost;\n    }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\nconst decodeImpl = (0,_Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.c)({\n    renderer: three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer,\n    createMaterial: (params)=>new GainMapDecoderMaterial(params),\n    createQuadRenderer: (params)=>new _QuadRenderer_Y5tm_R3m_js__WEBPACK_IMPORTED_MODULE_3__.Q(params)\n});\n/**\n * Decodes a gain map using a WebGL RenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */ const decode = (params)=>{\n    // Ensure renderer is defined for the base function\n    if (!params.renderer) {\n        throw new Error(\"Renderer is required for decode function\");\n    }\n    const quadRenderer = decodeImpl({\n        ...params,\n        renderer: params.renderer\n    });\n    try {\n        quadRenderer.render();\n    } catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n/**\n * Base class for WebGL loaders\n * @template TUrl - The type of URL used to load resources\n */ class LoaderBaseWebGL extends _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.L {\n    constructor(renderer, manager){\n        super({\n            renderer,\n            createMaterial: (params)=>new GainMapDecoderMaterial(params),\n            createQuadRenderer: (params)=>new _QuadRenderer_Y5tm_R3m_js__WEBPACK_IMPORTED_MODULE_3__.Q(params)\n        }, manager);\n    }\n    /**\n     * @private\n     * @param quadRenderer\n     * @param metadata\n     * @param sdrBuffer\n     * @param gainMapBuffer\n     */ async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        const { sdrImage, gainMapImage, needsFlip } = await this.processImages(sdrBuffer, gainMapBuffer, \"flipY\");\n        const { gainMap, sdr } = this.createTextures(sdrImage, gainMapImage, needsFlip);\n        this.updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata);\n        quadRenderer.render();\n    }\n}\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */ class GainMapLoader extends LoaderBaseWebGL {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a `ProgressEvent`\n     * @param onError Error callback\n     * @returns\n     */ load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async ()=>{\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                } catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === \"function\") onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === \"function\") onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = ()=>{\n            if (typeof onProgress === \"function\") {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent(\"progress\", {\n                    lengthComputable,\n                    loaded,\n                    total\n                }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType(\"arraybuffer\");\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof buffer === \"string\") throw new Error(\"Invalid sdr buffer\");\n            sdr = buffer;\n            await loadCheck();\n        }, (e)=>{\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        const gainMapLoader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType(\"arraybuffer\");\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof buffer === \"string\") throw new Error(\"Invalid gainmap buffer\");\n            gainMap = buffer;\n            await loadCheck();\n        }, (e)=>{\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        const metadataLoader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof json !== \"string\") throw new Error(\"Invalid metadata string\");\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e)=>{\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        return quadRenderer;\n    }\n}\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */ class HDRJPGLoader extends LoaderBaseWebGL {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url Path to a JPEG file containing embedded gain map metadata\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a `ProgressEvent`\n     * @param onError Error callback\n     * @returns\n     */ load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof jpeg === \"string\") throw new Error(\"Invalid buffer, received [string], was expecting [ArrayBuffer]\");\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await (0,_Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.e)(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            } catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.X || e instanceof _Loader_BZcKUVaX_js__WEBPACK_IMPORTED_MODULE_0__.G) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [\n                            0,\n                            0,\n                            0\n                        ],\n                        gainMapMax: [\n                            1,\n                            1,\n                            1\n                        ],\n                        gamma: [\n                            1,\n                            1,\n                            1\n                        ],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [\n                            0,\n                            0,\n                            0\n                        ],\n                        offsetSdr: [\n                            0,\n                            0,\n                            0\n                        ]\n                    };\n                    sdrJPEG = jpegBuffer;\n                } else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG.buffer, gainMapJPEG?.buffer);\n            } catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === \"function\") onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === \"function\") onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error)=>{\n            this.manager.itemError(url);\n            if (typeof onError === \"function\") onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFOEQ7QUFDZ0g7QUFDckc7QUFDYTtBQUV2RixNQUFNcUIsZUFBZSxRQUFRLEdBQUcsQ0FBQzs7Ozs7OztBQU9qQyxDQUFDO0FBQ0QsTUFBTUMsaUJBQWlCLFFBQVEsR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCbkMsQ0FBQztBQUNEOzs7OztDQUtDLEdBQ0QsTUFBTUMsK0JBQStCUCxpREFBY0E7SUFJL0M7OztLQUdDLEdBQ0RRLFlBQVksRUFBRUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLGVBQWUsRUFBRUMsY0FBYyxFQUFFQyxjQUFjLEVBQUVDLEdBQUcsRUFBRUMsT0FBTyxFQUFFLENBQUU7UUFDaEksS0FBSyxDQUFDO1lBQ0ZDLE1BQU07WUFDTmQ7WUFDQUM7WUFDQWMsVUFBVTtnQkFDTkgsS0FBSztvQkFBRUksT0FBT0o7Z0JBQUk7Z0JBQ2xCQyxTQUFTO29CQUFFRyxPQUFPSDtnQkFBUTtnQkFDMUJULE9BQU87b0JBQUVZLE9BQU8sSUFBSW5CLDBDQUFPQSxDQUFDLE1BQU1PLEtBQUssQ0FBQyxFQUFFLEVBQUUsTUFBTUEsS0FBSyxDQUFDLEVBQUUsRUFBRSxNQUFNQSxLQUFLLENBQUMsRUFBRTtnQkFBRTtnQkFDNUVDLFdBQVc7b0JBQUVXLE9BQU8sSUFBSW5CLDBDQUFPQSxHQUFHb0IsU0FBUyxDQUFDWjtnQkFBVztnQkFDdkRDLFdBQVc7b0JBQUVVLE9BQU8sSUFBSW5CLDBDQUFPQSxHQUFHb0IsU0FBUyxDQUFDWDtnQkFBVztnQkFDdkRDLFlBQVk7b0JBQUVTLE9BQU8sSUFBSW5CLDBDQUFPQSxHQUFHb0IsU0FBUyxDQUFDVjtnQkFBWTtnQkFDekRDLFlBQVk7b0JBQUVRLE9BQU8s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eS15ZWFycy8uL25vZGVfbW9kdWxlcy9AbW9ub2dyaWQvZ2Fpbm1hcC1qcy9kaXN0L2RlY29kZS5qcz9hMWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vbm9ncmlkL2dhaW5tYXAtanMgdjMuMi4wXG4gKiBXaXRoIOKdpO+4jywgYnkgTU9OT0dSSUQgPGdhaW5tYXBAbW9ub2dyaWQuY29tPlxuICovXG5cbmltcG9ydCB7IFEgYXMgUXVhZFJlbmRlcmVyIH0gZnJvbSAnLi9RdWFkUmVuZGVyZXItWTV0bS1SM20uanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVEZWNvZGVGdW5jdGlvbiwgTCBhcyBMb2FkZXJCYXNlU2hhcmVkLCBlIGFzIGV4dHJhY3RHYWlubWFwRnJvbUpQRUcsIFggYXMgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yLCBHIGFzIEdhaW5NYXBOb3RGb3VuZEVycm9yIH0gZnJvbSAnLi9Mb2FkZXItQlpjS1VWYVguanMnO1xuZXhwb3J0IHsgTSBhcyBNUEZFeHRyYWN0b3IsIGEgYXMgZXh0cmFjdFhNUCB9IGZyb20gJy4vTG9hZGVyLUJaY0tVVmFYLmpzJztcbmltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBOb0JsZW5kaW5nLCBWZWN0b3IzLCBXZWJHTFJlbmRlcmVyLCBGaWxlTG9hZGVyIH0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCB2ZXJ0ZXhTaGFkZXIgPSAvKiBnbHNsICovIGBcbnZhcnlpbmcgdmVjMiB2VXY7XG5cbnZvaWQgbWFpbigpIHtcbiAgdlV2ID0gdXY7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG59XG5gO1xuY29uc3QgZnJhZ21lbnRTaGFkZXIgPSAvKiBnbHNsICovIGBcbi8vIG1pbiBoYWxmIGZsb2F0IHZhbHVlXG4jZGVmaW5lIEhBTEZfRkxPQVRfTUlOIHZlYzMoIC02NTUwNCwgLTY1NTA0LCAtNjU1MDQgKVxuLy8gbWF4IGhhbGYgZmxvYXQgdmFsdWVcbiNkZWZpbmUgSEFMRl9GTE9BVF9NQVggdmVjMyggNjU1MDQsIDY1NTA0LCA2NTUwNCApXG5cbnVuaWZvcm0gc2FtcGxlcjJEIHNkcjtcbnVuaWZvcm0gc2FtcGxlcjJEIGdhaW5NYXA7XG51bmlmb3JtIHZlYzMgZ2FtbWE7XG51bmlmb3JtIHZlYzMgb2Zmc2V0SGRyO1xudW5pZm9ybSB2ZWMzIG9mZnNldFNkcjtcbnVuaWZvcm0gdmVjMyBnYWluTWFwTWluO1xudW5pZm9ybSB2ZWMzIGdhaW5NYXBNYXg7XG51bmlmb3JtIGZsb2F0IHdlaWdodEZhY3RvcjtcblxudmFyeWluZyB2ZWMyIHZVdjtcblxudm9pZCBtYWluKCkge1xuICB2ZWMzIHJnYiA9IHRleHR1cmUyRCggc2RyLCB2VXYgKS5yZ2I7XG4gIHZlYzMgcmVjb3ZlcnkgPSB0ZXh0dXJlMkQoIGdhaW5NYXAsIHZVdiApLnJnYjtcbiAgdmVjMyBsb2dSZWNvdmVyeSA9IHBvdyggcmVjb3ZlcnksIGdhbW1hICk7XG4gIHZlYzMgbG9nQm9vc3QgPSBnYWluTWFwTWluICogKCAxLjAgLSBsb2dSZWNvdmVyeSApICsgZ2Fpbk1hcE1heCAqIGxvZ1JlY292ZXJ5O1xuICB2ZWMzIGhkckNvbG9yID0gKHJnYiArIG9mZnNldFNkcikgKiBleHAyKCBsb2dCb29zdCAqIHdlaWdodEZhY3RvciApIC0gb2Zmc2V0SGRyO1xuICB2ZWMzIGNsYW1wZWRIZHJDb2xvciA9IG1heCggSEFMRl9GTE9BVF9NSU4sIG1pbiggSEFMRl9GTE9BVF9NQVgsIGhkckNvbG9yICkpO1xuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjbGFtcGVkSGRyQ29sb3IgLCAxLjAgKTtcbn1cbmA7XG4vKipcbiAqIEEgTWF0ZXJpYWwgd2hpY2ggaXMgYWJsZSB0byBkZWNvZGUgdGhlIEdhaW5tYXAgaW50byBhIGZ1bGwgSERSIFJlcHJlc2VudGF0aW9uXG4gKlxuICogQGNhdGVnb3J5IE1hdGVyaWFsc1xuICogQGdyb3VwIE1hdGVyaWFsc1xuICovXG5jbGFzcyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xuICAgIF9tYXhEaXNwbGF5Qm9vc3Q7XG4gICAgX2hkckNhcGFjaXR5TWluO1xuICAgIF9oZHJDYXBhY2l0eU1heDtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGdhbW1hLCBvZmZzZXRIZHIsIG9mZnNldFNkciwgZ2Fpbk1hcE1pbiwgZ2Fpbk1hcE1heCwgbWF4RGlzcGxheUJvb3N0LCBoZHJDYXBhY2l0eU1pbiwgaGRyQ2FwYWNpdHlNYXgsIHNkciwgZ2Fpbk1hcCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWU6ICdHYWluTWFwRGVjb2Rlck1hdGVyaWFsJyxcbiAgICAgICAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICBzZHI6IHsgdmFsdWU6IHNkciB9LFxuICAgICAgICAgICAgICAgIGdhaW5NYXA6IHsgdmFsdWU6IGdhaW5NYXAgfSxcbiAgICAgICAgICAgICAgICBnYW1tYTogeyB2YWx1ZTogbmV3IFZlY3RvcjMoMS4wIC8gZ2FtbWFbMF0sIDEuMCAvIGdhbW1hWzFdLCAxLjAgLyBnYW1tYVsyXSkgfSxcbiAgICAgICAgICAgICAgICBvZmZzZXRIZHI6IHsgdmFsdWU6IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KG9mZnNldEhkcikgfSxcbiAgICAgICAgICAgICAgICBvZmZzZXRTZHI6IHsgdmFsdWU6IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KG9mZnNldFNkcikgfSxcbiAgICAgICAgICAgICAgICBnYWluTWFwTWluOiB7IHZhbHVlOiBuZXcgVmVjdG9yMygpLmZyb21BcnJheShnYWluTWFwTWluKSB9LFxuICAgICAgICAgICAgICAgIGdhaW5NYXBNYXg6IHsgdmFsdWU6IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KGdhaW5NYXBNYXgpIH0sXG4gICAgICAgICAgICAgICAgd2VpZ2h0RmFjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoTWF0aC5sb2cyKG1heERpc3BsYXlCb29zdCkgLSBoZHJDYXBhY2l0eU1pbikgLyAoaGRyQ2FwYWNpdHlNYXggLSBoZHJDYXBhY2l0eU1pbilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcsXG4gICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGhXcml0ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21heERpc3BsYXlCb29zdCA9IG1heERpc3BsYXlCb29zdDtcbiAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNaW4gPSBoZHJDYXBhY2l0eU1pbjtcbiAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNYXggPSBoZHJDYXBhY2l0eU1heDtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHNkcigpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2RyLnZhbHVlOyB9XG4gICAgc2V0IHNkcih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLnNkci52YWx1ZSA9IHZhbHVlOyB9XG4gICAgZ2V0IGdhaW5NYXAoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLmdhaW5NYXAudmFsdWU7IH1cbiAgICBzZXQgZ2Fpbk1hcCh2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLmdhaW5NYXAudmFsdWUgPSB2YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5vZmZzZXRIZHJ9XG4gICAgICovXG4gICAgZ2V0IG9mZnNldEhkcigpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMub2Zmc2V0SGRyLnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgIHNldCBvZmZzZXRIZHIodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5vZmZzZXRIZHIudmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5vZmZzZXRTZHJ9XG4gICAgICovXG4gICAgZ2V0IG9mZnNldFNkcigpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMub2Zmc2V0U2RyLnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgIHNldCBvZmZzZXRTZHIodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5vZmZzZXRTZHIudmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5nYWluTWFwTWlufVxuICAgICAqL1xuICAgIGdldCBnYWluTWFwTWluKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5nYWluTWFwTWluLnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgIHNldCBnYWluTWFwTWluKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMuZ2Fpbk1hcE1pbi52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmdhaW5NYXBNYXh9XG4gICAgICovXG4gICAgZ2V0IGdhaW5NYXBNYXgoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNYXgudmFsdWUudG9BcnJheSgpOyB9XG4gICAgc2V0IGdhaW5NYXBNYXgodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5nYWluTWFwTWF4LnZhbHVlLmZyb21BcnJheSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuZ2FtbWF9XG4gICAgICovXG4gICAgZ2V0IGdhbW1hKCkge1xuICAgICAgICBjb25zdCBnID0gdGhpcy51bmlmb3Jtcy5nYW1tYS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIFsxIC8gZy54LCAxIC8gZy55LCAxIC8gZy56XTtcbiAgICB9XG4gICAgc2V0IGdhbW1hKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLnVuaWZvcm1zLmdhbW1hLnZhbHVlO1xuICAgICAgICBnLnggPSAxLjAgLyB2YWx1ZVswXTtcbiAgICAgICAgZy55ID0gMS4wIC8gdmFsdWVbMV07XG4gICAgICAgIGcueiA9IDEuMCAvIHZhbHVlWzJdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuaGRyQ2FwYWNpdHlNaW59XG4gICAgICogQHJlbWFya3MgTG9nYXJpdGhtaWMgc3BhY2VcbiAgICAgKi9cbiAgICBnZXQgaGRyQ2FwYWNpdHlNaW4oKSB7IHJldHVybiB0aGlzLl9oZHJDYXBhY2l0eU1pbjsgfVxuICAgIHNldCBoZHJDYXBhY2l0eU1pbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZHJDYXBhY2l0eU1pbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVdlaWdodCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuaGRyQ2FwYWNpdHlNaW59XG4gICAgICogQHJlbWFya3MgTG9nYXJpdGhtaWMgc3BhY2VcbiAgICAgKi9cbiAgICBnZXQgaGRyQ2FwYWNpdHlNYXgoKSB7IHJldHVybiB0aGlzLl9oZHJDYXBhY2l0eU1heDsgfVxuICAgIHNldCBoZHJDYXBhY2l0eU1heCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZHJDYXBhY2l0eU1heCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVdlaWdodCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWlubWFwRGVjb2RpbmdQYXJhbWV0ZXJzLm1heERpc3BsYXlCb29zdH1cbiAgICAgKiBAcmVtYXJrcyBOb24gTG9nYXJpdGhtaWMgc3BhY2VcbiAgICAgKi9cbiAgICBnZXQgbWF4RGlzcGxheUJvb3N0KCkgeyByZXR1cm4gdGhpcy5fbWF4RGlzcGxheUJvb3N0OyB9XG4gICAgc2V0IG1heERpc3BsYXlCb29zdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tYXhEaXNwbGF5Qm9vc3QgPSBNYXRoLm1heCgxLCBNYXRoLm1pbig2NTUwNCwgdmFsdWUpKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVXZWlnaHQoKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlV2VpZ2h0KCkge1xuICAgICAgICBjb25zdCB2YWwgPSAoTWF0aC5sb2cyKHRoaXMuX21heERpc3BsYXlCb29zdCkgLSB0aGlzLl9oZHJDYXBhY2l0eU1pbikgLyAodGhpcy5faGRyQ2FwYWNpdHlNYXggLSB0aGlzLl9oZHJDYXBhY2l0eU1pbik7XG4gICAgICAgIHRoaXMudW5pZm9ybXMud2VpZ2h0RmFjdG9yLnZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsKSk7XG4gICAgfVxufVxuXG5jb25zdCBkZWNvZGVJbXBsID0gY3JlYXRlRGVjb2RlRnVuY3Rpb24oe1xuICAgIHJlbmRlcmVyOiBXZWJHTFJlbmRlcmVyLFxuICAgIGNyZWF0ZU1hdGVyaWFsOiAocGFyYW1zKSA9PiBuZXcgR2Fpbk1hcERlY29kZXJNYXRlcmlhbChwYXJhbXMpLFxuICAgIGNyZWF0ZVF1YWRSZW5kZXJlcjogKHBhcmFtcykgPT4gbmV3IFF1YWRSZW5kZXJlcihwYXJhbXMpXG59KTtcbi8qKlxuICogRGVjb2RlcyBhIGdhaW4gbWFwIHVzaW5nIGEgV2ViR0wgUmVuZGVyVGFyZ2V0XG4gKlxuICogQGNhdGVnb3J5IERlY29kaW5nIEZ1bmN0aW9uc1xuICogQGdyb3VwIERlY29kaW5nIEZ1bmN0aW9uc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGRlY29kZSB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICogaW1wb3J0IHtcbiAqICAgTWVzaCxcbiAqICAgTWVzaEJhc2ljTWF0ZXJpYWwsXG4gKiAgIFBlcnNwZWN0aXZlQ2FtZXJhLFxuICogICBQbGFuZUdlb21ldHJ5LFxuICogICBTY2VuZSxcbiAqICAgVGV4dHVyZUxvYWRlcixcbiAqICAgV2ViR0xSZW5kZXJlclxuICogfSBmcm9tICd0aHJlZSdcbiAqXG4gKiBjb25zdCByZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKClcbiAqXG4gKiBjb25zdCB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKVxuICpcbiAqIC8vIGxvYWQgU0RSIFJlcHJlc2VudGF0aW9uXG4gKiBjb25zdCBzZHIgPSBhd2FpdCB0ZXh0dXJlTG9hZGVyLmxvYWRBc3luYygnc2RyLmpwZycpXG4gKiAvLyBsb2FkIEdhaW4gbWFwIHJlY292ZXJ5IGltYWdlXG4gKiBjb25zdCBnYWluTWFwID0gYXdhaXQgdGV4dHVyZUxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBnJylcbiAqIC8vIGxvYWQgbWV0YWRhdGFcbiAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgKGF3YWl0IGZldGNoKCdtZXRhZGF0YS5qc29uJykpLmpzb24oKVxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGRlY29kZSh7XG4gKiAgIHNkcixcbiAqICAgZ2Fpbk1hcCxcbiAqICAgLy8gdGhpcyBhbGxvd3MgdG8gdXNlIGByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVgIGRpcmVjdGx5XG4gKiAgIHJlbmRlcmVyLFxuICogICAvLyB0aGlzIHdpbGwgcmVzdG9yZSB0aGUgZnVsbCBIRFIgcmFuZ2VcbiAqICAgbWF4RGlzcGxheUJvb3N0OiBNYXRoLnBvdygyLCBtZXRhZGF0YS5oZHJDYXBhY2l0eU1heCksXG4gKiAgIC4uLm1ldGFkYXRhXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKClcbiAqIC8vIGByZXN1bHRgIGNhbiBiZSB1c2VkIHRvIHBvcHVsYXRlIGEgVGV4dHVyZVxuICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKFxuICogICBuZXcgUGxhbmVHZW9tZXRyeSgpLFxuICogICBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KVxuICogKVxuICogc2NlbmUuYWRkKG1lc2gpXG4gKiByZW5kZXJlci5yZW5kZXIoc2NlbmUsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpKVxuICpcbiAqIC8vIHJlc3VsdCBtdXN0IGJlIG1hbnVhbGx5IGRpc3Bvc2VkXG4gKiAvLyB3aGVuIHlvdSBhcmUgZG9uZSB1c2luZyBpdFxuICogcmVzdWx0LmRpc3Bvc2UoKVxuICpcbiAqIEBwYXJhbSBwYXJhbXNcbiAqIEByZXR1cm5zXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIFdlYkdMUmVuZGVyZXIgZmFpbHMgdG8gcmVuZGVyIHRoZSBnYWluIG1hcFxuICovXG5jb25zdCBkZWNvZGUgPSAocGFyYW1zKSA9PiB7XG4gICAgLy8gRW5zdXJlIHJlbmRlcmVyIGlzIGRlZmluZWQgZm9yIHRoZSBiYXNlIGZ1bmN0aW9uXG4gICAgaWYgKCFwYXJhbXMucmVuZGVyZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlciBpcyByZXF1aXJlZCBmb3IgZGVjb2RlIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHF1YWRSZW5kZXJlciA9IGRlY29kZUltcGwoe1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHJlbmRlcmVyOiBwYXJhbXMucmVuZGVyZXJcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgICBxdWFkUmVuZGVyZXIucmVuZGVyKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHF1YWRSZW5kZXJlci5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gcXVhZFJlbmRlcmVyO1xufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBXZWJHTCBsb2FkZXJzXG4gKiBAdGVtcGxhdGUgVFVybCAtIFRoZSB0eXBlIG9mIFVSTCB1c2VkIHRvIGxvYWQgcmVzb3VyY2VzXG4gKi9cbmNsYXNzIExvYWRlckJhc2VXZWJHTCBleHRlbmRzIExvYWRlckJhc2VTaGFyZWQge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBtYW5hZ2VyKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgY3JlYXRlTWF0ZXJpYWw6IChwYXJhbXMpID0+IG5ldyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsKHBhcmFtcyksXG4gICAgICAgICAgICBjcmVhdGVRdWFkUmVuZGVyZXI6IChwYXJhbXMpID0+IG5ldyBRdWFkUmVuZGVyZXIocGFyYW1zKVxuICAgICAgICB9LCBtYW5hZ2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gcXVhZFJlbmRlcmVyXG4gICAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHNkckJ1ZmZlclxuICAgICAqIEBwYXJhbSBnYWluTWFwQnVmZmVyXG4gICAgICovXG4gICAgYXN5bmMgcmVuZGVyKHF1YWRSZW5kZXJlciwgbWV0YWRhdGEsIHNkckJ1ZmZlciwgZ2Fpbk1hcEJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNkckltYWdlLCBnYWluTWFwSW1hZ2UsIG5lZWRzRmxpcCB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzSW1hZ2VzKHNkckJ1ZmZlciwgZ2Fpbk1hcEJ1ZmZlciwgJ2ZsaXBZJyk7XG4gICAgICAgIGNvbnN0IHsgZ2Fpbk1hcCwgc2RyIH0gPSB0aGlzLmNyZWF0ZVRleHR1cmVzKHNkckltYWdlLCBnYWluTWFwSW1hZ2UsIG5lZWRzRmxpcCk7XG4gICAgICAgIHRoaXMudXBkYXRlUXVhZFJlbmRlcmVyKHF1YWRSZW5kZXJlciwgc2RySW1hZ2UsIGdhaW5NYXAsIHNkciwgbWV0YWRhdGEpO1xuICAgICAgICBxdWFkUmVuZGVyZXIucmVuZGVyKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgVGhyZWUuanMgTG9hZGVyIGZvciB0aGUgZ2FpbiBtYXAgZm9ybWF0LlxuICpcbiAqIEBjYXRlZ29yeSBMb2FkZXJzXG4gKiBAZ3JvdXAgTG9hZGVyc1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBHYWluTWFwTG9hZGVyIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gKiBpbXBvcnQge1xuICogICBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcbiAqICAgTWVzaCxcbiAqICAgTWVzaEJhc2ljTWF0ZXJpYWwsXG4gKiAgIFBlcnNwZWN0aXZlQ2FtZXJhLFxuICogICBQbGFuZUdlb21ldHJ5LFxuICogICBTY2VuZSxcbiAqICAgV2ViR0xSZW5kZXJlclxuICogfSBmcm9tICd0aHJlZSdcbiAqXG4gKiBjb25zdCByZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKClcbiAqXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgR2Fpbk1hcExvYWRlcihyZW5kZXJlcilcbiAqICAgLnNldFJlbmRlclRhcmdldE9wdGlvbnMoeyBtYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyB9KVxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoWydzZHIuanBlZycsICdnYWlubWFwLmpwZWcnLCAnbWV0YWRhdGEuanNvbiddKVxuICogLy8gYHJlc3VsdGAgY2FuIGJlIHVzZWQgdG8gcG9wdWxhdGUgYSBUZXh0dXJlXG4gKlxuICogY29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKVxuICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKFxuICogICBuZXcgUGxhbmVHZW9tZXRyeSgpLFxuICogICBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KVxuICogKVxuICogc2NlbmUuYWRkKG1lc2gpXG4gKiByZW5kZXJlci5yZW5kZXIoc2NlbmUsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpKVxuICpcbiAqIC8vIFN0YXJ0aW5nIGZyb20gdGhyZWUuanMgcjE1OVxuICogLy8gYHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZWAgY2FuXG4gKiAvLyBhbHNvIGJlIHVzZWQgYXMgRXF1aXJlY3Rhbmd1bGFyIHNjZW5lIGJhY2tncm91bmRcbiAqIC8vXG4gKiAvLyBpdCB3YXMgcHJldmlvdXNseSBuZWVkZWQgdG8gY29udmVydCBpdFxuICogLy8gdG8gYSBEYXRhVGV4dHVyZSB3aXRoIGByZXN1bHQudG9EYXRhVGV4dHVyZSgpYFxuICogc2NlbmUuYmFja2dyb3VuZCA9IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZVxuICpcbiAqIC8vIHJlc3VsdCBtdXN0IGJlIG1hbnVhbGx5IGRpc3Bvc2VkXG4gKiAvLyB3aGVuIHlvdSBhcmUgZG9uZSB1c2luZyBpdFxuICogcmVzdWx0LmRpc3Bvc2UoKVxuICpcbiAqL1xuY2xhc3MgR2Fpbk1hcExvYWRlciBleHRlbmRzIExvYWRlckJhc2VXZWJHTCB7XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBnYWlubWFwIHVzaW5nIHNlcGFyYXRlIGRhdGFcbiAgICAgKiAqIHNkciBpbWFnZVxuICAgICAqICogZ2FpbiBtYXAgaW1hZ2VcbiAgICAgKiAqIG1ldGFkYXRhIGpzb25cbiAgICAgKlxuICAgICAqIHVzZWZ1bCBmb3Igd2VicCBnYWluIG1hcHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmxzIEFuIGFycmF5IGluIHRoZSBmb3JtIG9mIFtzZHIuanBnLCBnYWlubWFwLmpwZywgbWV0YWRhdGEuanNvbl1cbiAgICAgKiBAcGFyYW0gb25Mb2FkIExvYWQgY29tcGxldGUgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIG9uUHJvZ3Jlc3MgUHJvZ3Jlc3MgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSBhIGBQcm9ncmVzc0V2ZW50YFxuICAgICAqIEBwYXJhbSBvbkVycm9yIEVycm9yIGNhbGxiYWNrXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBsb2FkKFtzZHJVcmwsIGdhaW5NYXBVcmwsIG1ldGFkYXRhVXJsXSwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IHF1YWRSZW5kZXJlciA9IHRoaXMucHJlcGFyZVF1YWRSZW5kZXJlcigpO1xuICAgICAgICBsZXQgc2RyO1xuICAgICAgICBsZXQgZ2Fpbk1hcDtcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICBjb25zdCBsb2FkQ2hlY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2RyICYmIGdhaW5NYXAgJiYgbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBzb2x2ZXMgIzE2XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXIocXVhZFJlbmRlcmVyLCBtZXRhZGF0YSwgc2RyLCBnYWluTWFwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3Ioc2RyVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihnYWluTWFwVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uTG9hZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkKHF1YWRSZW5kZXJlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQoc2RyVXJsKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZChnYWluTWFwVXJsKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZChtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBzZHJMZW5ndGhDb21wdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgbGV0IHNkclRvdGFsID0gMDtcbiAgICAgICAgbGV0IHNkckxvYWRlZCA9IDA7XG4gICAgICAgIGxldCBnYWluTWFwTGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XG4gICAgICAgIGxldCBnYWluTWFwVG90YWwgPSAwO1xuICAgICAgICBsZXQgZ2Fpbk1hcExvYWRlZCA9IDA7XG4gICAgICAgIGxldCBtZXRhZGF0YUxlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgICAgICBsZXQgbWV0YWRhdGFUb3RhbCA9IDA7XG4gICAgICAgIGxldCBtZXRhZGF0YUxvYWRlZCA9IDA7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gc2RyVG90YWwgKyBnYWluTWFwVG90YWwgKyBtZXRhZGF0YVRvdGFsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHNkckxvYWRlZCArIGdhaW5NYXBMb2FkZWQgKyBtZXRhZGF0YUxvYWRlZDtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhDb21wdXRhYmxlID0gc2RyTGVuZ3RoQ29tcHV0YWJsZSAmJiBnYWluTWFwTGVuZ3RoQ29tcHV0YWJsZSAmJiBtZXRhZGF0YUxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhuZXcgUHJvZ3Jlc3NFdmVudCgncHJvZ3Jlc3MnLCB7IGxlbmd0aENvbXB1dGFibGUsIGxvYWRlZCwgdG90YWwgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHNkclVybCk7XG4gICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQoZ2Fpbk1hcFVybCk7XG4gICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQobWV0YWRhdGFVcmwpO1xuICAgICAgICBjb25zdCBzZHJMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgc2RyTG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcbiAgICAgICAgc2RyTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgc2RyTG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgc2RyTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIHNkckxvYWRlci5sb2FkKHNkclVybCwgYXN5bmMgKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZHIgYnVmZmVyJyk7XG4gICAgICAgICAgICBzZHIgPSBidWZmZXI7XG4gICAgICAgICAgICBhd2FpdCBsb2FkQ2hlY2soKTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIHNkckxlbmd0aENvbXB1dGFibGUgPSBlLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICBzZHJMb2FkZWQgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgIHNkclRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcigpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3Ioc2RyVXJsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGdhaW5NYXBMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgZ2Fpbk1hcExvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG4gICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICBnYWluTWFwTG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgZ2Fpbk1hcExvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICBnYWluTWFwTG9hZGVyLmxvYWQoZ2Fpbk1hcFVybCwgYXN5bmMgKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBnYWlubWFwIGJ1ZmZlcicpO1xuICAgICAgICAgICAgZ2Fpbk1hcCA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRDaGVjaygpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgZ2Fpbk1hcExlbmd0aENvbXB1dGFibGUgPSBlLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICBnYWluTWFwTG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICBnYWluTWFwVG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKCk7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihnYWluTWFwVXJsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgIC8vIG1ldGFkYXRhTG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnanNvbicpXG4gICAgICAgIG1ldGFkYXRhTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgbWV0YWRhdGFMb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgICBtZXRhZGF0YUxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICBtZXRhZGF0YUxvYWRlci5sb2FkKG1ldGFkYXRhVXJsLCBhc3luYyAoanNvbikgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0YWRhdGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgY2hlY2sgb24gSlNPTiBmaWxlIGFuZCByZW1vdmUgdGhpcyBlc2xpbnQgZGlzYWJsZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgbWV0YWRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICAgICAgYXdhaXQgbG9hZENoZWNrKCk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBtZXRhZGF0YUxlbmd0aENvbXB1dGFibGUgPSBlLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICBtZXRhZGF0YUxvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgbWV0YWRhdGFUb3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXIoKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgVGhyZWUuanMgTG9hZGVyIGZvciBhIEpQRUcgd2l0aCBlbWJlZGRlZCBnYWlubWFwIG1ldGFkYXRhLlxuICpcbiAqIEBjYXRlZ29yeSBMb2FkZXJzXG4gKiBAZ3JvdXAgTG9hZGVyc1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBIRFJKUEdMb2FkZXIgfSBmcm9tICdAbW9ub2dyaWQvZ2Fpbm1hcC1qcydcbiAqIGltcG9ydCB7XG4gKiAgIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuICogICBNZXNoLFxuICogICBNZXNoQmFzaWNNYXRlcmlhbCxcbiAqICAgUGVyc3BlY3RpdmVDYW1lcmEsXG4gKiAgIFBsYW5lR2VvbWV0cnksXG4gKiAgIFNjZW5lLFxuICogICBXZWJHTFJlbmRlcmVyXG4gKiB9IGZyb20gJ3RocmVlJ1xuICpcbiAqIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKVxuICpcbiAqIGNvbnN0IGxvYWRlciA9IG5ldyBIRFJKUEdMb2FkZXIocmVuZGVyZXIpXG4gKiAgIC5zZXRSZW5kZXJUYXJnZXRPcHRpb25zKHsgbWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfSlcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCdnYWlubWFwLmpwZWcnKVxuICogLy8gYHJlc3VsdGAgY2FuIGJlIHVzZWQgdG8gcG9wdWxhdGUgYSBUZXh0dXJlXG4gKlxuICogY29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKVxuICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKFxuICogICBuZXcgUGxhbmVHZW9tZXRyeSgpLFxuICogICBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KVxuICogKVxuICogc2NlbmUuYWRkKG1lc2gpXG4gKiByZW5kZXJlci5yZW5kZXIoc2NlbmUsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpKVxuICpcbiAqIC8vIFN0YXJ0aW5nIGZyb20gdGhyZWUuanMgcjE1OVxuICogLy8gYHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZWAgY2FuXG4gKiAvLyBhbHNvIGJlIHVzZWQgYXMgRXF1aXJlY3Rhbmd1bGFyIHNjZW5lIGJhY2tncm91bmRcbiAqIC8vXG4gKiAvLyBpdCB3YXMgcHJldmlvdXNseSBuZWVkZWQgdG8gY29udmVydCBpdFxuICogLy8gdG8gYSBEYXRhVGV4dHVyZSB3aXRoIGByZXN1bHQudG9EYXRhVGV4dHVyZSgpYFxuICogc2NlbmUuYmFja2dyb3VuZCA9IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZVxuICpcbiAqIC8vIHJlc3VsdCBtdXN0IGJlIG1hbnVhbGx5IGRpc3Bvc2VkXG4gKiAvLyB3aGVuIHlvdSBhcmUgZG9uZSB1c2luZyBpdFxuICogcmVzdWx0LmRpc3Bvc2UoKVxuICpcbiAqL1xuY2xhc3MgSERSSlBHTG9hZGVyIGV4dGVuZHMgTG9hZGVyQmFzZVdlYkdMIHtcbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIEpQRUcgY29udGFpbmluZyBnYWluIG1hcCBtZXRhZGF0YVxuICAgICAqIFJlbmRlcnMgYSBub3JtYWwgU0RSIGltYWdlIGlmIGdhaW5tYXAgZGF0YSBpcyBub3QgZm91bmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgUGF0aCB0byBhIEpQRUcgZmlsZSBjb250YWluaW5nIGVtYmVkZGVkIGdhaW4gbWFwIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIG9uTG9hZCBMb2FkIGNvbXBsZXRlIGNhbGxiYWNrLCB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSBvblByb2dyZXNzIFByb2dyZXNzIGNhbGxiYWNrLCB3aWxsIHJlY2VpdmUgYSBgUHJvZ3Jlc3NFdmVudGBcbiAgICAgKiBAcGFyYW0gb25FcnJvciBFcnJvciBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgICAgICBjb25zdCBxdWFkUmVuZGVyZXIgPSB0aGlzLnByZXBhcmVRdWFkUmVuZGVyZXIoKTtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG4gICAgICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgICAgIGxvYWRlci5sb2FkKHVybCwgYXN5bmMgKGpwZWcpID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgIHRoaXMgY29uZGl0aW9uIGV4aXN0cyBvbmx5IGJlY2F1c2Ugb2YgdGhyZWUuanMgdHlwZXMgKyBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YganBlZyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ1ZmZlciwgcmVjZWl2ZWQgW3N0cmluZ10sIHdhcyBleHBlY3RpbmcgW0FycmF5QnVmZmVyXScpO1xuICAgICAgICAgICAgY29uc3QganBlZ0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGpwZWcpO1xuICAgICAgICAgICAgbGV0IHNkckpQRUc7XG4gICAgICAgICAgICBsZXQgZ2Fpbk1hcEpQRUc7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhY3Rpb25SZXN1bHQgPSBhd2FpdCBleHRyYWN0R2Fpbm1hcEZyb21KUEVHKGpwZWdCdWZmZXIpO1xuICAgICAgICAgICAgICAgIC8vIGdhaW4gbWFwIGlzIHN1Y2Nlc3NmdWxseSByZWNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgICAgc2RySlBFRyA9IGV4dHJhY3Rpb25SZXN1bHQuc2RyO1xuICAgICAgICAgICAgICAgIGdhaW5NYXBKUEVHID0gZXh0cmFjdGlvblJlc3VsdC5nYWluTWFwO1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gZXh0cmFjdGlvblJlc3VsdC5tZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBTRFIgdmVyc2lvbiBpZiB0aGlzIGlzIG5vdCBhIGdhaW5tYXBcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciB8fCBlIGluc3RhbmNlb2YgR2Fpbk1hcE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsdXJlIHRvIHJlY29uc3RydWN0IGFuIEhEUiBpbWFnZSBmcm9tICR7dXJsfTogR2FpbiBtYXAgbWV0YWRhdGEgbm90IGZvdW5kIGluIHRoZSBmaWxlLCBIRFJKUEdMb2FkZXIgd2lsbCByZW5kZXIgdGhlIFNEUiBqcGVnYCk7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2Fpbk1hcE1pbjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2Fpbk1hcE1heDogWzEsIDEsIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FtbWE6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWluOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNYXg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRIZHI6IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFNkcjogWzAsIDAsIDBdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNkckpQRUcgPSBqcGVnQnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzb2x2ZXMgIzE2XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyKHF1YWRSZW5kZXJlciwgbWV0YWRhdGEsIHNkckpQRUcuYnVmZmVyLCBnYWluTWFwSlBFRz8uYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHF1YWRSZW5kZXJlci5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIG9uTG9hZChxdWFkUmVuZGVyZXIpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICB9LCBvblByb2dyZXNzLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG4gICAgfVxufVxuXG5leHBvcnQgeyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsLCBHYWluTWFwTG9hZGVyLCBHYWluTWFwTm90Rm91bmRFcnJvciwgSERSSlBHTG9hZGVyLCBIRFJKUEdMb2FkZXIgYXMgSlBFR1JMb2FkZXIsIExvYWRlckJhc2VTaGFyZWQsIFF1YWRSZW5kZXJlciwgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yLCBjcmVhdGVEZWNvZGVGdW5jdGlvbiwgZGVjb2RlLCBleHRyYWN0R2Fpbm1hcEZyb21KUEVHIH07XG4iXSwibmFtZXMiOlsiUSIsIlF1YWRSZW5kZXJlciIsImMiLCJjcmVhdGVEZWNvZGVGdW5jdGlvbiIsIkwiLCJMb2FkZXJCYXNlU2hhcmVkIiwiZSIsImV4dHJhY3RHYWlubWFwRnJvbUpQRUciLCJYIiwiWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yIiwiRyIsIkdhaW5NYXBOb3RGb3VuZEVycm9yIiwiTSIsIk1QRkV4dHJhY3RvciIsImEiLCJleHRyYWN0WE1QIiwiU2hhZGVyTWF0ZXJpYWwiLCJOb0JsZW5kaW5nIiwiVmVjdG9yMyIsIldlYkdMUmVuZGVyZXIiLCJGaWxlTG9hZGVyIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJHYWluTWFwRGVjb2Rlck1hdGVyaWFsIiwiY29uc3RydWN0b3IiLCJnYW1tYSIsIm9mZnNldEhkciIsIm9mZnNldFNkciIsImdhaW5NYXBNaW4iLCJnYWluTWFwTWF4IiwibWF4RGlzcGxheUJvb3N0IiwiaGRyQ2FwYWNpdHlNaW4iLCJoZHJDYXBhY2l0eU1heCIsInNkciIsImdhaW5NYXAiLCJuYW1lIiwidW5pZm9ybXMiLCJ2YWx1ZSIsImZyb21BcnJheSIsIndlaWdodEZhY3RvciIsIk1hdGgiLCJsb2cyIiwiYmxlbmRpbmciLCJkZXB0aFRlc3QiLCJkZXB0aFdyaXRlIiwiX21heERpc3BsYXlCb29zdCIsIl9oZHJDYXBhY2l0eU1pbiIsIl9oZHJDYXBhY2l0eU1heCIsIm5lZWRzVXBkYXRlIiwidW5pZm9ybXNOZWVkVXBkYXRlIiwidG9BcnJheSIsImciLCJ4IiwieSIsInoiLCJjYWxjdWxhdGVXZWlnaHQiLCJtYXgiLCJtaW4iLCJ2YWwiLCJkZWNvZGVJbXBsIiwicmVuZGVyZXIiLCJjcmVhdGVNYXRlcmlhbCIsInBhcmFtcyIsImNyZWF0ZVF1YWRSZW5kZXJlciIsImRlY29kZSIsIkVycm9yIiwicXVhZFJlbmRlcmVyIiwicmVuZGVyIiwiZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIiLCJMb2FkZXJCYXNlV2ViR0wiLCJtYW5hZ2VyIiwibWV0YWRhdGEiLCJzZHJCdWZmZXIiLCJnYWluTWFwQnVmZmVyIiwic2RySW1hZ2UiLCJnYWluTWFwSW1hZ2UiLCJuZWVkc0ZsaXAiLCJwcm9jZXNzSW1hZ2VzIiwiY3JlYXRlVGV4dHVyZXMiLCJ1cGRhdGVRdWFkUmVuZGVyZXIiLCJHYWluTWFwTG9hZGVyIiwibG9hZCIsInNkclVybCIsImdhaW5NYXBVcmwiLCJtZXRhZGF0YVVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwicHJlcGFyZVF1YWRSZW5kZXJlciIsImxvYWRDaGVjayIsImVycm9yIiwiaXRlbUVycm9yIiwiaXRlbUVuZCIsInNkckxlbmd0aENvbXB1dGFibGUiLCJzZHJUb3RhbCIsInNkckxvYWRlZCIsImdhaW5NYXBMZW5ndGhDb21wdXRhYmxlIiwiZ2Fpbk1hcFRvdGFsIiwiZ2Fpbk1hcExvYWRlZCIsIm1ldGFkYXRhTGVuZ3RoQ29tcHV0YWJsZSIsIm1ldGFkYXRhVG90YWwiLCJtZXRhZGF0YUxvYWRlZCIsInByb2dyZXNzSGFuZGxlciIsInRvdGFsIiwibG9hZGVkIiwibGVuZ3RoQ29tcHV0YWJsZSIsIlByb2dyZXNzRXZlbnQiLCJpdGVtU3RhcnQiLCJzZHJMb2FkZXIiLCJfaW50ZXJuYWxMb2FkaW5nTWFuYWdlciIsInNldFJlc3BvbnNlVHlwZSIsInNldFJlcXVlc3RIZWFkZXIiLCJyZXF1ZXN0SGVhZGVyIiwic2V0UGF0aCIsInBhdGgiLCJzZXRXaXRoQ3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJidWZmZXIiLCJnYWluTWFwTG9hZGVyIiwibWV0YWRhdGFMb2FkZXIiLCJqc29uIiwiSlNPTiIsInBhcnNlIiwiSERSSlBHTG9hZGVyIiwidXJsIiwibG9hZGVyIiwianBlZyIsImpwZWdCdWZmZXIiLCJVaW50OEFycmF5Iiwic2RySlBFRyIsImdhaW5NYXBKUEVHIiwiZXh0cmFjdGlvblJlc3VsdCIsImNvbnNvbGUiLCJ3YXJuIiwiSlBFR1JMb2FkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js\n");

/***/ })

};
;